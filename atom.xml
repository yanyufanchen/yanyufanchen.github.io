<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大前端技术分享</title>
  
  <subtitle>大前端技术分享</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-03T09:39:57.528Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>凡尘</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【原创】ThreeJsModelViewer三维模型查看器</title>
    <link href="http://example.com/posts/csjakjkse/"/>
    <id>http://example.com/posts/csjakjkse/</id>
    <published>2023-03-03T09:04:04.175Z</published>
    <updated>2023-03-03T09:39:57.528Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><blockquote><p>三维模型查看器!</p></blockquote><p align="center">    <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d83a86e294424d8eaedc8c7d3a457fd2~tplv-k3u1fbpfcp-watermark.image?" width="260" alt="threejs vue 三维模型查看器"></p><h1 align="center">Welcome to Vue_ThreeModelViewer 👋</h1><p>  <img alt="Version" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7db6abf9197c49ea97c6907a81caf35d~tplv-k3u1fbpfcp-zoom-1.image" />  <a href="https://juejin.im/post/6864410873709592584/" target="_blank">    <img alt="Documentation" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90733de7a5604cf7bf0c9ac17a4f61c6~tplv-k3u1fbpfcp-zoom-1.image" />  </a>  <a href="#" target="_blank">    <img alt="license:GPL3.0" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4eb339c00174732823657ce33c77e88~tplv-k3u1fbpfcp-zoom-1.image" />  </a></p><blockquote><p>Vue_ThreeModelViewer 是一款功能强大的模型查看器项目，致力于提供一套简单方便、无限可能的原生 ThreeJs 在 Vue 项目中的封装与实现。技术栈以 threejs 和 Vue2.6 为主,对于模型预览的可视化控件、工具后期会逐步增加和完善。</p></blockquote><blockquote><p>Vue_ThreeModelViewer is a powerful model viewer project that aims to provide a set of simple and convenient encapsulation and implementation of native ThreeJs in Vue projects. The technology stack is dominated by threejs and Vue2.6, and the visual controls and tools for model preview will be gradually increased and improved in the later stage.</p></blockquote><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><h4 id="github地址：https-github-com-yanyufanchen-threejsmodelviewer"><a href="#github地址：https-github-com-yanyufanchen-threejsmodelviewer" class="headerlink" title="github地址：https://github.com/yanyufanchen/threejsmodelviewer"></a>github地址：<a href="https://github.com/yanyufanchen/threejsmodelviewer">https://github.com/yanyufanchen/threejsmodelviewer</a></h4><h4 id="gitee地址：https-gitee-com-yanyufanchen-threejsmodelviewer"><a href="#gitee地址：https-gitee-com-yanyufanchen-threejsmodelviewer" class="headerlink" title="gitee地址：https://gitee.com/yanyufanchen/threejsmodelviewer"></a>gitee地址：<a href="https://gitee.com/yanyufanchen/threejsmodelviewer">https://gitee.com/yanyufanchen/threejsmodelviewer</a></h4><h3 id="🏠-Homepage"><a href="#🏠-Homepage" class="headerlink" title="🏠 Homepage"></a>🏠 <a href="http://yanyufanchen.gitee.io/threejsmodelviewer">Homepage</a></h3><h3 id="视频教程-Video-tutorial-–待添加"><a href="#视频教程-Video-tutorial-–待添加" class="headerlink" title="视频教程 | Video tutorial –待添加"></a><a href="">视频教程 | Video tutorial –待添加</a></h3><table><thead><tr><th>主页 🏠(home)</th><th>演示 ✨(demo)</th><th>文档 📦(doc)</th><th>教程(tutorial)</th><th>wiki</th></tr></thead><tbody><tr><td><a href="http://yanyufanchen.gitee.io/threejsmodelviewer">website</a></td><td><a href="http://yanyufanchen.gitee.io/threejsmodelviewer">Demo</a></td><td><a href="./public/docs/textCourse.md">Document</a></td><td><a href="">视频&amp;Video</a></td><td><a href="">wiki</a></td></tr></tbody></table><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><p>👤 <strong>凡尘</strong></p><ul><li>Website:</li><li>Github: <a href="https://github.com/yanyufanchen">@yanyufanchen</a></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>未获得授权的情况下，禁止对该仓库代码进行反编译、分发等行为，否则将承担相应的法律后果。</p><h2 id="🤝-Contributing"><a href="#🤝-Contributing" class="headerlink" title="🤝 Contributing"></a>🤝 Contributing</h2><p>Contributions, issues and feature requests are welcome!<br />Feel free to check <a href="https://github.com/yanyufanchen/ThreeJsModelViewer/issues">issues page</a>.</p><p>欢迎提供问题和功能需求, 如果大家有好的点子和优化建议, 也欢迎提 pr 参与我们的共建.</p><h2 id="Show-your-support"><a href="#Show-your-support" class="headerlink" title="Show your support"></a>Show your support</h2><p>Give a ⭐️ if this project helped you!<br>如果觉得项目还不错, 就点个 star 吧~</p><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ol><li><p>首页</p><ul><li><input checked="" disabled="" type="checkbox"> 模型列表</li><li><input checked="" disabled="" type="checkbox"> 模型下载</li></ul></li><li><p>模型查看器</p><ul><li><input checked="" disabled="" type="checkbox"> 模型预加载</li><li><input checked="" disabled="" type="checkbox"> 顶部工具栏</li><li><input checked="" disabled="" type="checkbox"> 右侧查看器控件面板</li></ul></li><li><p>数据支持</p><ul><li><input checked="" disabled="" type="checkbox"> unicloud 云存储</li></ul></li></ol><h2 id="技术栈-The-technology-stack"><a href="#技术栈-The-technology-stack" class="headerlink" title="技术栈 | The technology stack"></a>技术栈 | The technology stack</h2><ul><li><strong>Vue2</strong> 前端主流框架(react,vue,angular)之一,更适合快速搭建和团队合作的应用</li><li><strong>sass</strong> css 预编译语言，轻松编写结构化分明的 css</li><li><strong>antd</strong> 地球人都知道的 UI 组件库</li><li><strong>unicloud</strong> 优秀的 serverless 云服务系统</li></ul><h2 id="Install-安装"><a href="#Install-安装" class="headerlink" title="Install(安装)"></a>Install(安装)</h2><ol><li>下载代码 | Download the code</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">github</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/yanyufanchen/ThreeJsModelViewer.git</span><br><span class="line">gitee</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/yanyufanchen/ThreeJsModelViewer.git</span><br></pre></td></tr></table></figure><ol start="2"><li>进入项目目录 | Go to the project catalog</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./ThreeJsModelViewer</span><br></pre></td></tr></table></figure><ol start="3"><li>安装依赖包 | Install the dependency package</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn install</span><br><span class="line">or</span><br><span class="line">cnpm install</span><br></pre></td></tr></table></figure><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>本地启动应用 | Launch the app locally</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yarn serve</span><br><span class="line">or</span><br><span class="line">cnpm run serve</span><br></pre></td></tr></table></figure><h2 id="更新日志-Update-the-log"><a href="#更新日志-Update-the-log" class="headerlink" title="更新日志 | Update the log"></a>更新日志 | Update the log</h2><ol><li>优化模型加载后释放缓存</li></ol><h2 id="持续升级-Continuous-upgrades"><a href="#持续升级-Continuous-upgrades" class="headerlink" title="持续升级 | Continuous upgrades"></a>持续升级 | Continuous upgrades</h2><p>正在完善顶部工具栏，敬请期待…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="threejs" scheme="http://example.com/tags/threejs/"/>
    
  </entry>
  
  <entry>
    <title>【原创】WUI云桌面系统</title>
    <link href="http://example.com/posts/adsdsafc/"/>
    <id>http://example.com/posts/adsdsafc/</id>
    <published>2023-03-03T08:43:54.571Z</published>
    <updated>2023-03-03T09:43:06.384Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p align="center">    <a href="https://yanyufanchen.gitee.io/wui-desktop" target="_blank">项目演示</a> |    <a href="https://uniapp.dcloud.io/README" target="_blank">uniapp官方文档</a>  |    <a href="https://uniapp.dcloud.io/uniCloud/README" target="_blank">uniCloud官方文档</a> </p><p align="center">    <img src="https://gitee.com/yanyufanchen/wui-desktop/badge/star.svg?theme=dark" />    <img src="https://gitee.com/yanyufanchen/wui-desktop/badge/fork.svg?theme=dark" />    <img src="https://svg.hamm.cn/badge.svg?key=License&value=Apache-2.0&color=da4a00" />    <img src="https://svg.hamm.cn/badge.svg?key=wui-desktop&value=v1.2.0" /></p>-    YUI云桌面系统，前端使用Vue2.x + Element UI，目前支持PC端，后台服务支撑采用uniCloud(基于Nodejs,云数据库、云函数、云存储)，代码托管在gitee并使用Pages做页面展示。-    在这里感谢<img src="https://svg.hamm.cn/badge.svg?key=uniCloud&value=3.3.7-alpha" />平台提供的阿里云服务，目前个人使用并不收费，彻底摆脱了私有化服务器的运维成本。-    并配合gitee的pages服务，无需域名和服务器便可实现全栈项目的部署和迭代更新。<ul><li> 如果觉着还不错的话，就请点个 ⭐star 支持一下吧，这将是对我最大的支持和鼓励！</li></ul><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><h4 id="github地址：https-github-com-yanyufanchen-wui-desktop"><a href="#github地址：https-github-com-yanyufanchen-wui-desktop" class="headerlink" title="github地址：https://github.com/yanyufanchen/wui-desktop"></a>github地址：<a href="https://github.com/yanyufanchen/wui-desktop">https://github.com/yanyufanchen/wui-desktop</a></h4><h4 id="gitee地址：https-gitee-com-yanyufanchen-wui-desktop"><a href="#gitee地址：https-gitee-com-yanyufanchen-wui-desktop" class="headerlink" title="gitee地址：https://gitee.com/yanyufanchen/wui-desktop"></a>gitee地址：<a href="https://gitee.com/yanyufanchen/wui-desktop">https://gitee.com/yanyufanchen/wui-desktop</a></h4><h2 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h2><ol><li><p>登录板块</p><table> <tr>     <td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69acd21462774eb5bb724268d0a613ce~tplv-k3u1fbpfcp-watermark.image?"></td> </tr></table></li><li><p>桌面板块</p><table> <tr>     <td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/122d74a07d9b4b55b11fe8200c1b0d11~tplv-k3u1fbpfcp-watermark.image?"></td>     <td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e0f125e67b2423b919d23d0c96ffb74~tplv-k3u1fbpfcp-watermark.image?"></td> </tr><tr>   <td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02ec89501baa47a1afbc6262cffd869e~tplv-k3u1fbpfcp-watermark.image?"></td>   <td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ca50b2196474548bedfe32be54ce148~tplv-k3u1fbpfcp-watermark.image?"></td></tr></table></li></ol><ol start="3"><li><p>我的电脑、是一个在线资源管理器，可存储多种格式资源，并提供在线预览功能</p><table> <tr>     <td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d4f26152cb4177951d0c5f928fa033~tplv-k3u1fbpfcp-watermark.image?"></td>     <td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a2bab46572b41c3ac7fde01d60a9fa9~tplv-k3u1fbpfcp-watermark.image?"></td> </tr></table></li><li><p>浏览器、提供常规网页搜索功能</p><table> <tr>     <td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d339540c68d0444297d04521ecd0a89b~tplv-k3u1fbpfcp-watermark.image?"></td>     <td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcf9c7a33fad4682874d0f2f1a8c528f~tplv-k3u1fbpfcp-watermark.image?"></td> </tr></table></li><li><p>应用商店、是系统继承的应用管理，可以提供用户安装应用和卸载，后期会持续更新和扩展应用，这也是该云桌面系统的核心功能</p><table><tr><td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20cc7c5f86bd46fab3c4aa72a8644f66~tplv-k3u1fbpfcp-watermark.image?"></td><td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57fdec4c49034ddd9329bb2d127c65d8~tplv-k3u1fbpfcp-watermark.image?"></td></tr></table></li><li><p>系统设置、提供云桌面配置的设置，如壁纸上传更换，用户信息设置等。</p><table><tr><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28f45a36cfde46cfb59adc2d47e1faff~tplv-k3u1fbpfcp-watermark.image?"></td><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79205d03d42c43e9aa86308fc4f4a32c~tplv-k3u1fbpfcp-watermark.image?"></td><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00f73cd5c2f34e02bed6c2e6bc8617b6~tplv-k3u1fbpfcp-watermark.image?"></td></tr><tr><td><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb419d7a6174dc5a656c99342135e28~tplv-k3u1fbpfcp-watermark.image?"></td><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb7d5033a134e27b5615f9ec2dcc4ef~tplv-k3u1fbpfcp-watermark.image?"></td><td><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/786010a1300f4ec3aaf5be2e5e363f1b~tplv-k3u1fbpfcp-watermark.image?"></td></tr></table></li></ol><h2 id="环境需求"><a href="#环境需求" class="headerlink" title="环境需求"></a>环境需求</h2><ul><li>HBuilderX 3.X uniapp开发编辑器</li><li>uniCloud账号</li></ul><h2 id="下载项目"><a href="#下载项目" class="headerlink" title="下载项目"></a>下载项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/yanyufanchen/wui-desktop.git &amp;&amp; cd wui-desktop</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="后端安装"><a href="#后端安装" class="headerlink" title="后端安装"></a>后端安装</h2><p>uniCloud-aliyun文件夹极为云服务的本地文件</p><p>1、关联云服务空间</p></table><tr><td><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f35f826f9ca45dda552286695ca3a74~tplv-k3u1fbpfcp-watermark.image?g"></td></tr></table><p>2、初始化云函数</p><table><tr><td><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/805b6b2008694870b36dffa09c85db1d~tplv-k3u1fbpfcp-watermark.image?"></td></tr></table><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>使用编辑器的运行按钮启动项目</p><h2 id="体验地址"><a href="#体验地址" class="headerlink" title="体验地址"></a>体验地址</h2><p><a href="https://yanyufanchen.gitee.io/wui-desktop/">体验地址</a></p><ul><li>账号：visitor001</li><li>密码：123456</li></ul><blockquote><p>请勿添加脏数据</p></blockquote><h2 id="开发功能点"><a href="#开发功能点" class="headerlink" title="开发功能点"></a>开发功能点</h2><h3 id="v1-2"><a href="#v1-2" class="headerlink" title="v1.2"></a>v1.2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">桌面</span><br><span class="line">【更新】完成桌面基础功能搭建</span><br><span class="line">【更新】增加锁屏功能</span><br><span class="line">【更新】增加退出登录功能</span><br><span class="line">我的电脑</span><br><span class="line">【更新】完成资源管理功能(包括文件预览功能)</span><br><span class="line">浏览器</span><br><span class="line">【更新】完成基础搜索引擎搭建</span><br><span class="line">应用商店</span><br><span class="line">【更新】完成系统应用展示</span><br><span class="line">【更新】完成我的应用展示</span><br><span class="line">系统设置和用户设置</span><br><span class="line">【更新】系统设置组件开发</span><br><span class="line">系统壁纸，主题色可视化配置，</span><br><span class="line">针对管理员的功能板块，如系统应用创建</span><br><span class="line">【更新】用户设置组件归属于系统设置</span><br><span class="line">【更新】用户设置组件开发</span><br><span class="line">【更新】针对管理员的功能板块</span><br><span class="line"> 应用设置、用户设置</span><br><span class="line">【更新】个人设置-个人密码、主题色、壁纸等设置</span><br><span class="line">【更新】其他-意见反馈板块</span><br><span class="line">【更新】关于-系统参数</span><br><span class="line">【修复】时间栏组件优化</span><br></pre></td></tr></table></figure><h3 id="待完成功能"><a href="#待完成功能" class="headerlink" title="待完成功能"></a>待完成功能</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">桌面</span><br><span class="line"> 左侧菜单组件完善</span><br><span class="line"> 底部栏组件自适应优化</span><br><span class="line"> 消息通知组件开发</span><br><span class="line">我的电脑</span><br><span class="line">  刷新、后退按钮功能实现</span><br><span class="line">浏览器</span><br><span class="line">  主页开发</span><br></pre></td></tr></table></figure><h2 id="QQ群"><a href="#QQ群" class="headerlink" title="QQ群"></a>QQ群</h2><blockquote><img src="https://img.shields.io/badge/Q群-暂无-red.svg" /></blockquote><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><blockquote><p>以下排名不分先后</p></blockquote><p><a href="https://www.dcloud.io/">DCloud uniapp的开发平台</a></p><p><a href="https://uniapp.dcloud.io/">uniapp 前端跨平台解决方案</a></p><p><a href="https://uniapp.dcloud.net.cn/uniCloud/README">uniCloud 为开发者提供的云服务平台</a></p><p><a href="https://element.eleme.cn/#/zh-CN/guide/design">Element ui前端UI框架</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="uniapp" scheme="http://example.com/tags/uniapp/"/>
    
    <category term="全栈" scheme="http://example.com/tags/%E5%85%A8%E6%A0%88/"/>
    
    <category term="云开发" scheme="http://example.com/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【原创】基于Uniapp和UniCloud开发的全栈博客项目3.0</title>
    <link href="http://example.com/posts/21cfbf15/"/>
    <id>http://example.com/posts/21cfbf15/</id>
    <published>2023-03-03T07:54:11.519Z</published>
    <updated>2023-03-03T09:38:39.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="基于Uniapp和UniCloud开发的全栈博客项目3-0"><a href="#基于Uniapp和UniCloud开发的全栈博客项目3-0" class="headerlink" title="基于Uniapp和UniCloud开发的全栈博客项目3.0"></a>基于Uniapp和UniCloud开发的全栈博客项目3.0</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9213dfdc9fdd4958b7f2439f068c8edf~tplv-k3u1fbpfcp-zoom-crop-mark:1512:1512:1512:851.awebp" alt="image.png"></p><style>    .flexCenter {        display:flex;        justify-content: start;        align-items: center;    }</style><p class="flexCenter">    <img src="https://badgen.net/github/stars/yanyufanchen/unimy_blog?theme=dark" />    <img src="https://badgen.net/github/forks/yanyufanchen/unimy_blog?theme=dark" />    <img src="https://svg.hamm.cn/badge.svg?key=License&value=Apache-2.0&color=da4a00" />    <img src="https://svg.hamm.cn/badge.svg?key=案例展示&value=v1.0.0" /></p><p>*如果觉着还不错的话，就请点个 ⭐star 支持一下吧，这将是对我最大的支持和鼓励！</p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><h4 id="github地址：https-github-com-yanyufanchen-unimy-blog"><a href="#github地址：https-github-com-yanyufanchen-unimy-blog" class="headerlink" title="github地址：https://github.com/yanyufanchen/unimy_blog"></a>github地址：<a href="https://github.com/yanyufanchen/unimy_blog">https://github.com/yanyufanchen/unimy_blog</a></h4><h4 id="gitee地址：https-gitee-com-yanyufanchen-unimy-blog"><a href="#gitee地址：https-gitee-com-yanyufanchen-unimy-blog" class="headerlink" title="gitee地址：https://gitee.com/yanyufanchen/unimy_blog"></a>gitee地址：<a href="https://gitee.com/yanyufanchen/unimy_blog">https://gitee.com/yanyufanchen/unimy_blog</a></h4><h3 id="基于-uniCloud-element-的-前后台博客项目"><a href="#基于-uniCloud-element-的-前后台博客项目" class="headerlink" title="基于 uniCloud + element 的 前后台博客项目"></a>基于 uniCloud + element 的 前后台博客项目</h3><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本项目是采用uniappH5开发的，集成了前台和后台PC博客项目，所有请求数据都使用了unicloud提供的阿里云函数+云数据库，可部署上线。</span><br></pre></td></tr></table></figure><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ul><li>uniapp（）</li><li>element-ui（）</li><li>Markdown编辑器（）</li><li>vue2.x（）</li><li>vueX（）</li><li></li></ul><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、cloudfunctions文件夹右键选择云空间(uniapp提供的免费空间)</span><br><span class="line">2、上传云函数以及云数据库</span><br><span class="line">3、采用HBuilder运行项目</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="发布上线"><a href="#发布上线" class="headerlink" title="发布上线"></a>发布上线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="FileTree-目录结构"><a href="#FileTree-目录结构" class="headerlink" title="FileTree 目录结构"></a>FileTree 目录结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── bin                       // node 命令行构建工具 (无)</span><br><span class="line">├── unpackage                     // 构建相关  </span><br><span class="line">├── config                     // 配置相关 (无)</span><br><span class="line">├── src                        // 源代码</span><br><span class="line">│   ├── api                    // 所有请求</span><br><span class="line">│   ├── components             // 全局UI组件</span><br><span class="line">│   ├── mock                   // mock数据(无)</span><br><span class="line">│   ├── router                 // 路由 (无)</span><br><span class="line">│   ├── store                  // 全局store管理</span><br><span class="line">│   ├── common                  // 全局公用方法</span><br><span class="line">│   ├── containers              // 自适应布局组合 (无)</span><br><span class="line">│   ├── page                  // view界面</span><br><span class="line">│   │    ├── admin            //后台</span><br><span class="line">│   │    ├── index         //前台</span><br><span class="line">│   │    ├── login              //登录界面(无)</span><br><span class="line">│   │    ├── errorPages           //错误界面(无)</span><br><span class="line">│   │    └── permission        //权限测试界面(无)</span><br><span class="line">│   ├── App.vue                // 入口页面</span><br><span class="line">│   └── main.js                // 入口 加载组件 初始化等</span><br><span class="line">├── static                     // 静态资源</span><br><span class="line">│   ├── bower_components        //七牛SDK(无)</span><br><span class="line">│   ├── css                     //css</span><br><span class="line">│   ├── js                      //js</span><br><span class="line">├── .babelrc                   // babel-loader 配置</span><br><span class="line">├── eslintrc.js                // eslint 配置项(无)</span><br><span class="line">├── .pages.json                // uniapp专属路由</span><br><span class="line">├── favicon.ico                // favicon图标</span><br><span class="line">├── index.html                 // html模板(无)</span><br><span class="line">└── package.json               // package.json</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="插件说明"><a href="#插件说明" class="headerlink" title="插件说明"></a>插件说明</h4><p>1、marked mackdown文档样式化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">安装：npm install marked</span><br><span class="line">使用方法：<span class="attr">https</span>:<span class="comment">//blog.csdn.net/weixin_45894305/article/details/106362783?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</span></span><br></pre></td></tr></table></figure><h4 id="项目开发中遇到的bug"><a href="#项目开发中遇到的bug" class="headerlink" title="项目开发中遇到的bug"></a>项目开发中遇到的bug</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、JS切换背景图片时的“白色闪屏”问题(banner栏动态更换海报)</span><br><span class="line">说明：</span><br><span class="line">原先采用行内式赋值：// this.Bgc=&#x27;background-image: url(../../../static/medias/banner/&#x27;+ new Date().getDay() +&#x27;.jpg);&#x27;</span><br><span class="line">原因，图片加载需要一定的时间，所以就会出现短暂的闪烁</span><br><span class="line">解决：</span><br><span class="line">// 修复切换背景图时出现的“白色闪屏”现象</span><br><span class="line">let img = new Image();</span><br><span class="line">img.src = bannerList[Num].url</span><br><span class="line">// 确定图片加载完成后再进行背景图片切换</span><br><span class="line">img.onload = ()=&gt; &#123;</span><br><span class="line">this.$(&#x27;.el-header&#x27;).css(&quot;background-image&quot;,&quot;url(&quot; + img.src + &quot;)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h4><h4 id="更新计划"><a href="#更新计划" class="headerlink" title="更新计划"></a>更新计划</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、增加token写入</span><br><span class="line">2、增加云函数token校验</span><br></pre></td></tr></table></figure><h4 id="鸣谢："><a href="#鸣谢：" class="headerlink" title="鸣谢："></a>鸣谢：</h4><p>1、uniapp官方</p><p>2、vue官方</p><p>3、uni-cloud-element-admin（serverless 后台管理系统）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="uniapp" scheme="http://example.com/tags/uniapp/"/>
    
    <category term="全栈" scheme="http://example.com/tags/%E5%85%A8%E6%A0%88/"/>
    
    <category term="云开发" scheme="http://example.com/tags/%E4%BA%91%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【转载】我在工作中是如何使用 git 的 - 掘金</title>
    <link href="http://example.com/posts/undefined/"/>
    <id>http://example.com/posts/undefined/</id>
    <published>2023-03-02T02:20:09.596Z</published>
    <updated>2023-03-02T02:22:32.653Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65101a7d9d694e6fb4c72a020a80ab4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><blockquote><p>这是第 103 篇不掺水的原创，想获取更多原创好文，请搜索公众号关注我们吧~ 本文首发于政采云前端博客：<a href="https://link.juejin.cn/?target=https://zoo.team/article/how-to-use-git" title="https://zoo.team/article/how-to-use-git">我在工作中是如何使用 git 的</a></p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c21fe17bec4446fcb90c68d271b958de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="奕承.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10be51db41754da791aea92c067a95cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在网上有个真实发生的案例比较火，说的是一个新入职的员工，不会用 Git 拉代码，第二天被开除。由此，可见 Git 对我们工作的重要性，无论是前端后端，都是离不开 Git 的，下面就让我们一探究竟吧。</p><p>上面的案例引申出一个问题，入职一家新公司，你的 leader 给你分配了仓库的权限后，如何配置本地的 Git 环境并拉取代码？莫慌，按照下面我讲的四个步骤走，保证你可以顺利使用 Git 进行拉取代码！</p><ol><li>下载 Git <a href="https://link.juejin.cn/?target=https://git-scm.com/downloads" title="https://git-scm.com/downloads">下载地址</a> ，选择自己系统对应的版本下载即可。</li><li>在你的电脑上生成 ssh 秘钥，打开终端，执行 <code>ssh-keygen -t rsa -C &quot;你公司内部邮箱地址&quot;</code>，如果执行成功，切换到 <code>~/.ssh</code> 目录下，此时目录应该如下所示。复制 <code>id_rsa.pub</code> 的内容。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0deb58d91310414f80eff364c694af9c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519163921819.png"></li><li>这里以 Github 为例，如下图所示，进入 <code>settings -&gt; SSH and GPG keys</code> 通过 <code>cat</code> 命令查看文件 <code>id_rsa.pub</code> 的内容，然后复制过来，点击 <code>add ssh key</code>，这一步等于说把你的公钥放到了 Github 上进行托管。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff633573cc946bab9a13f014a099d7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519164643069.png"></li><li>全局配置 Git 的用户名和邮箱</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx@xx.com&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>完成以上四步，你就可以愉快 pull 代码开发了。和 https 拉取方式不同的是，https 方式需要每次提交前都手动输入用户名和密码，ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。</p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>在介绍 Git 的相关操作前，我觉得非常有必要了解 Git 的由来，以及 Git 是用来解决什么问题的。Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Linus Torvalds ，这个人我相信大家都知道吧，开源 Linux 系统的发明人。如今，你看到的大部分服务器其实都是运行在 Linux 系统上，令人感到称叹的是，这位大神级别的程序员不仅创造了 Linux 系统。那 Linux 的代码是如何管理的呢？2002年之前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！要知道，当时的 Linux 的代码量已经很大了，通过人工管理的方式，一是容易出错，二是效率低。于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。最后，出于某种原因，BitMover 公司收回了 Linux 社区的免费使用权，于是 Linus 花了两周时间自己用 C 语言 写了一个分布式版本控制系统，这就是 Git 的由来了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1363adc08773478eb98e278660322996~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><h2 id="Git-的工作区域和流程"><a href="#Git-的工作区域和流程" class="headerlink" title="Git 的工作区域和流程"></a>Git 的工作区域和流程</h2><p>要想弄懂 Git 是怎么对我们的代码进行管理的，那首当其冲的是了解 Git 的工作区域是如何构成的。因为，只有彻底弄懂了 Git 工作区域的构成，你才可以在适当的区域使用合适的命令。如下图所示，此图包含了 Git 的4个工作区和一些常见的操作。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec7210655b4d4fc4afcd1466d9aa2343~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="git"></p><p>Workspace：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作</p><p>Index：暂存区，当执行 <code>git add</code> 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中那些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 <code>git add</code> 先提交到暂存区。</p><p>Repository：本地仓库，位于自己的电脑上，通过 <code>git commit</code> 提交暂存区的内容，会进入本地仓库。</p><p>Remote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 <code>git push</code> 命令同步代码到远程仓库。</p><p>一般来说，Git 的工作流程分为以下几步</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在工作区开发，添加，修改文件。</span><br><span class="line">2.将修改后的文件放入暂存区。</span><br><span class="line">3.将暂存区域的文件提交到本地仓库。</span><br><span class="line">4.将本地仓库的修改推送到远程仓库。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>添加文件到暂存区</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加某个文件到暂存区，后面可以跟多个文件，以空格区分</span><br><span class="line">git add xxx</span><br><span class="line"># 添加当前更改的所有文件到暂存区。</span><br><span class="line">git add .</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提交暂存的更改，会新开编辑器进行编辑</span><br><span class="line">git commit </span><br><span class="line"># 提交暂存的更改，并记录下备注</span><br><span class="line">git commit -m &quot;you message&quot;</span><br><span class="line"># 等同于 git add . &amp;&amp; git commit -m</span><br><span class="line">git commit -am</span><br><span class="line"># 对最近一次的提交的信息进行修改,此操作会修改commit的hash值</span><br><span class="line">git commit --amend</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从远程仓库拉取代码并合并到本地，可简写为 git pull 等同于 git fetch &amp;&amp; git merge </span><br><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line"># 使用rebase的模式进行合并</span><br><span class="line">git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>与 <code>git pull</code> 不同的是 <code>git fetch</code> 操作仅仅只会拉取远程的更改，不会自动进行 merge 操作。对你当前的代码没有影响</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取远程仓库特定分支的更新</span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class="line"># 获取远程仓库所有分支的更新</span><br><span class="line">git fetch --all</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建本地分支，但不切换</span><br><span class="line">git branch &lt;branch-name&gt; </span><br><span class="line"># 查看本地分支</span><br><span class="line">git branch</span><br><span class="line"># 查看远程分支</span><br><span class="line">git branch -r</span><br><span class="line"># 查看本地和远程分支</span><br><span class="line">git branch -a</span><br><span class="line"># 删除本地分支</span><br><span class="line">git branch -D &lt;branch-nane&gt;</span><br><span class="line"># 重新命名分支</span><br><span class="line">git branch -m &lt;old-branch-name&gt; &lt;new-branch-name&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="工作中使用-Git-解决问题的场景"><a href="#工作中使用-Git-解决问题的场景" class="headerlink" title="工作中使用 Git 解决问题的场景"></a>工作中使用 Git 解决问题的场景</h2><h3 id="git-rebase-让你的提交记录更加清晰可读"><a href="#git-rebase-让你的提交记录更加清晰可读" class="headerlink" title="git rebase 让你的提交记录更加清晰可读"></a>git rebase 让你的提交记录更加清晰可读</h3><h4 id="git-rebase-的使用"><a href="#git-rebase-的使用" class="headerlink" title="git rebase 的使用"></a>git rebase 的使用</h4><p>rebase 翻译为变基，他的作用和 merge 很相似，用于把一个分支的修改合并到当前分支上。</p><p>如下图所示，下图介绍了经过 rebase 后提交历史的变化情况。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b169721a6bfc42a7b4754f7c5d65672d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="WechatIMG2.png"></p><p>现在我们来用一个例子来解释一下上面的过程。</p><p>假设我们现在有2条分支，一个为 master，一个为 feature/1，他们都基于初始的一个提交 add readme 进行检出分支，之后，master 分支增加了 3.js 和 4.js 的文件，分别进行了2次提交，feature/1 也增加了 1.js 和 2.js 的文件，分别对应以下2条提交记录。</p><p>此时，对应分支的提交记录如下。</p><p>master 分支如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64147d864ec44c3494560c3547010bbe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210531144909187.png"></p><p>feature/1 分支如下图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81543f378abd4a16bf74947d2200ffa9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210531145504071.png"></p><p>结合起来看是这样的</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35519191523f4568bf6135bfcfb223a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210531145553107.png"></p><p>此时，切换到 feature/1 分支下，执行 <code>git rebase master</code>，成功之后，通过 <code>git log</code> 查看记录。</p><p>如下图所示：可以看到先是逐个应用了 mater 分支的更改，然后以 master 分支最后的提交作为基点，再逐个应用 feature/1 的每个更改。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb57edd0b594ff6ad7bc7d25ba128f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210531150719965.png"></p><p>所以，我们的提交记录就会非常清晰，没有分叉，上面演示的是比较顺利的情况，但是大部分情况下，rebase 的过程中会产生冲突的，此时，就需要手动解决冲突，然后使用依次 <code>git add</code> 、<code>git rebase --continue</code> 的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 <code>git rebase --skip</code> 来跳过这次 rebase 操作。</p><h4 id="git-merge-和-git-rebase-的区别"><a href="#git-merge-和-git-rebase-的区别" class="headerlink" title="git merge 和 git rebase 的区别"></a>git merge 和 git rebase 的区别</h4><p>不同于 <code>git rebase</code> 的是，<code>git merge</code> 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 <code>Merge branch &#39;xxx&#39; into &#39;xxx&#39;</code> 的一条提交信息。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b182abe7c54161959596eb5b140299~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210531151838328.png"></p><p>另外，在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要依次解决每次的冲突，才可以提交。</p><h4 id="git-rebase-交互模式"><a href="#git-rebase-交互模式" class="headerlink" title="git rebase 交互模式"></a>git rebase 交互模式</h4><p>在开发中，常会遇到在一个分支上产生了很多的无效的提交，这种情况下使用 rebase 的交互式模式可以把已经发生的多次提交压缩成一次提交，得到了一个干净的提交历史，例如某个分支的提交历史情况如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee27b108f03443a58c19600cac7ddf70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210518211345258.png"></p><p>进入交互式模式的方式是执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;base-commit&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>参数 <code>base-commit</code> 就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作，对于上述提交历史的例子，我们要把最后的一个提交对象（ ac18084 ）之前的提交压缩成一次提交，我们需要执行的命令格式是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i ac18084</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此时会进入一个 vim 的交互式页面，编辑器列出的信息像下列这样。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fd2ea54dbbe4c88a51fc652c6b1e86f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210518212036198.png"></p><p>想要合并这一堆更改，我们要使用 Squash 策略进行合并，即把当前的 commit 和它的上一个 commit 内容进行合并， 大概可以表示为下面这样，在交互模式的 rebase 下，至少保留一个 pick，否则命令会执行失败。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick  ... ...</span><br><span class="line">s     ... ... </span><br><span class="line">s     ... ... </span><br><span class="line">s     ... ... </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>修改文件后 按下 <code>:</code> 然后 <code>wq</code> 保存退出，此时又会弹出一个编辑页面，这个页面是用来编辑提交的信息，修改为 <code>feat: 更正</code>，最后保存一下，接着使用 <code>git branch</code> 查看提交的 commit 信息，rebase 后的提交记录如下图所示，是不是清爽了很多？rebase 操作可以让我们的提交历史变得更加清晰。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2586ec49060f4dfc9006c8f3fc532260~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210518212812000.png"></p><blockquote><p>特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。</p></blockquote><h3 id="使用-git-cherry-pick-获取指定的-commit"><a href="#使用-git-cherry-pick-获取指定的-commit" class="headerlink" title="使用 git cherry-pick 获取指定的 commit"></a>使用 git cherry-pick 获取指定的 commit</h3><p><code>git cherry-pick</code> 可以理解为”挑拣”提交，和 merge 合并一个分支的所有提交不同的是，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用 <code>git cherry-pick</code> 了。</p><p>如下场景，以下有三条分支，feature/cherry-pick1 和 feature/cherry-pick2 都是基于 master 检出的两条功能性分支，对应的分支 log 记录如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66e205eb421841bfa476167e6fd7c581~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210518221001432.png"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5743a18a0c24b3aa085db3d7a620742~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210518221010458.png"></p><p>master 分支的提交如下 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64fe055a5e764ff58e85923314096f9e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210518221051734.png"></p><p>现在 master 只需要 feature/cherry-pick1 和 feature/cherry-pick2 有关 change 的修改，并不关心有关 fix 内容的修改。此时就可以用 cherry-pick 指令了。</p><p>语法： <code>git cherry-pick [commit-hash]</code></p><p>commit-hash 表示的是某次 commit 的 hash 值。现在，依次执行以下两条指令 <code>git cherry-pick e0bb7f3</code>、<code>git cherry-pick c9a3101</code>，过程中，如果出现冲突，解决冲突后 进行 <code>git add</code> ，接着执行 <code>git cherry-pick --continue</code>，最后，master 上的提交如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f9c71679824941abdf98b769b9a062~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210518235707190.png"></p><p>此时，master 分支上应用了需要的提交，就达到了我们想要的效果。如果需要多个 cherry-pick 需要同步到目标分支，可以简写为 <code>git cherry-pick &lt;first-commit-id&gt;...&lt;last-commit-id&gt;</code>，这是一个左开右闭的区间，也就时说 <code>first-commit-id</code> 提交带来的代码的改动不会被合并过去，如果需要合并过去，可以使用 <code>git cherry-pick &lt;first-commit-id&gt;^...&lt;last-commit-id&gt;</code>，它表示包含 <code>first-commit-id</code> 到 <code>last-commit-id</code> 在内的提交都会被合并过去。</p><h3 id="使用-git-revert-回滚某次的提交"><a href="#使用-git-revert-回滚某次的提交" class="headerlink" title="使用 git revert 回滚某次的提交"></a>使用 git revert 回滚某次的提交</h3><p>想象这么一个场景，你的项目最近有2个版本要上线，这两个版本还伴随着之前遗留的 bug 的修复，一开始的时候，你将 bug 修复在了第一个版本的 release 分支上，突然在发版前一天，测试那边反馈，需要把第一个版本修复 bug 的内容改在第二个版本上，这个时候，第一个版本的集成分支的提交应该包括了第一个版本的功能内容，遗留 bug 修复的提交和其他同事提交的内容，想要通过 reset 的方式粗暴摘除之前的关于 bug 修复的 commit 肯定是不行的，同时，这种做法比较危险，此时，我们既不想破坏之前的提交记录，又想撤回我们遗留 bug 的 commit 记录应该怎么做呢？git revert 就派上了用场。</p><blockquote><p><code>git revert</code> 撤销某次操作，此操作不会修改原本的提交记录，而是会新增一条提交记录来抵消某次操作。</p></blockquote><p>语法： <code>git revert &lt;commit-id&gt;</code> 针对普通 commit</p><p><code>git revert &lt;commit-id&gt; -m</code> 针对 merge 的 commit</p><p>下面就用一个案例来理解一下这个命令，如下图所示，假设被红框框起来的地方是会引起 bug 的一次提交，在他的提交之后，又进行了2次提交，其中包含了其它同事的提交。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f36331158e084072a033802bf4fa0478~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519142702752.png"></p><p>此时想把引起提交的 bug 的干掉，执行 <code>git revert 1121932</code>，执行操作后，再打开查看日志，如下图所示，可以看到是新增了一条 commit 记录，这个 commit 的产生的 msg 是自动生成的，Revert 开头，后面跟撤回的 commit-msg 信息 之前的 commit 记录并没有消失，此时也达到了代码回退的效果</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9729e537218e4609b54df3e899fd332f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519142824836.png"></p><p>此外 git revert 也可以回滚多次的提交</p><p>语法：<code>git revert [commit-id1] [commit-id2] ...</code> 注意这是一个前开后闭区间，即不包括 commit1 ，但包括 commit2 。</p><p>回滚我们的提交有二种方式，一种是上文提到的<code>git revert</code>命令外，还可以使用 <code>git reset</code> 命令，那么它们两者有什么区别呢？</p><p><code>git revert</code> 会新建一条 commit 信息，来撤回之前的修改。</p><p><code>git reset</code> 会直接将提交记录退回到指定的 commit 上。</p><p>对于个人的 feature 分支而言，可以使用 <code>git reset</code> 来回退历史记录，之后使用 <code>git push --force</code> 进行推送到远程，但是如果是在多人协作的集成分支上，不推荐直接使用 <code>git reset</code> 命令，而是使用更加安全的 <code>git revert</code> 命令进行撤回提交。这样，提交的历史记录不会被抹去，可以安全的进行撤回。</p><h3 id="使用-git-stash-来暂存文件"><a href="#使用-git-stash-来暂存文件" class="headerlink" title="使用 git stash 来暂存文件"></a>使用 git stash 来暂存文件</h3><p>会有这么一个场景，现在你正在用你的 feature 分支上开发新功能。这时，生产环境上出现了一个 bug 需要紧急修复，但是你这部分代码还没开发完，不想提交，怎么办？这个时候可以用 <code>git stash</code> 命令先把工作区已经修改的文件暂存起来，然后切换到 hotfix 分支上进行 bug 的修复，修复完成后，切换回 feature 分支，从堆栈中恢复刚刚保存的内容。</p><p>基本命令如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git stash //把本地的改动暂存起来</span><br><span class="line">git stash save &quot;message&quot; 执行存储时，添加备注，方便查找。</span><br><span class="line">git stash pop // 应用最近一次暂存的修改，并删除暂存的记录</span><br><span class="line">git stash apply  // 应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即 stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;$num&#125; 。</span><br><span class="line">git stash list // 查看 stash 有哪些存储</span><br><span class="line">git stash clear // 删除所有缓存的 stash</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>下面通过几幅图对 stash 的命令做进一步了解。</p><p>此时，我正在开发一个新功能，修改了 1.js 文件里的内容</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd64645d30734e68a4e4349ea94ee064~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519175036869.png"></p><p>还没开发完成，这个时候，我想切换到 hotfix 分支上修复 bug，得暂停下开发切换到 hotfix 分支，但是现在工作区还有内容，此时如果切换分支 Git 会报出下面的错误</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: Your local changes to the following files would be overwritten by checkout:</span><br><span class="line">        1.js</span><br><span class="line">Please commit your changes or stash them before you switch branches.</span><br><span class="line">Aborting</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上面那句话的意思就是说工作区有文件修改，不能提交，需要先进行 commit 或者 stash 操作，执行 <code>git stash</code>，结果如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Saved working directory and index state WIP on stash: 22e561c feat: add 1.js</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此时，我们的工作区已经干净了，可以切换到 hotfix 分支进行 bug 修复的工作，假设我们现在 bug 修复完成了，继续切回 feature 分支进行原本功能的开发，此时只需要执行 <code>git stash pop</code>，之前我们暂存的修改就会恢复到工作区，如下图所示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4f3a3b24e042868829315b3209b760~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519185011012.png"></p><p>当我们想要暂存文件，切换分支做某些事的时候，可以用 <code>git stash</code> 这种机制帮助开发。</p><p>推荐在使用 stash 的相关命令时，每一次暂存的时候，不要直接使用 <code>git stash</code> 命令进行暂存下来，而是使用 <code>git stash save &quot;message...&quot;</code> 这种方式，给本次的提交做一个信息的记录。这样，想应用更改的时候，先通过 <code>git stash list</code> 查看一下所有的暂存列表。之后，推荐使用 <code>git stash apply stash@$&#123;num&#125;</code> 的方式进行应用对应的 stash，这样不会清空已有的 stash 的列表项，并且能应用到当前的工作区，不需要这个暂存的话，再手动清除就可以了。</p><h3 id="不同的工作区域撤销更改"><a href="#不同的工作区域撤销更改" class="headerlink" title="不同的工作区域撤销更改"></a>不同的工作区域撤销更改</h3><p>开发中，我们经常需要回退代码的操作，在不同的工作区域中，回退代码的方式也是不相同的。如下图所示，假设现在要在 feature/revoke 分支上进行开发,</p><p>首先通过 <code>git status</code> 查看下现在的状态。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4ede8763be443868de951dc08721c1a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210520115802579.png"></p><p>目前我们的工作区是很干净的，没有任何修改的操作，此时，修改一下代码再次查看状态，可以看到，1.js 这个文件被修改了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/371084f06fca40778b2f95900ebf19b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210520115934693.png"></p><p>现在我们想把 1.js 这个文件恢复到修改前的状态，即撤回工作区的修改，就可以使用 <code>git checkout -- &lt;filename&gt;</code> 的命令，如果要撤回多个文件的修改，文件之间使用空格隔开，如下图所示，我们撤回了 1.js 文件的修改，工作区也恢复干净了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02da2adecc3b43bd917294c203596d1e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210520120242475.png"></p><p>如果说现在我们对文件进行了修改，并且已经提交到暂存区了，这部分文件我们不想要的话，那么就可以通过 <code>git reset &lt;filename&gt;</code> 的命令来对特定的文件进行撤销，<code>git reset</code> 会撤回所有存在暂存区的文件，如下图所示，查看前后的状态可知，文件最后成功撤回到工作区了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0d6b5e17ec341afb86e1e9732f2ded9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210520141538130.png"></p><h3 id="配置-git-alias-提升工作效率"><a href="#配置-git-alias-提升工作效率" class="headerlink" title="配置 git alias 提升工作效率"></a>配置 git alias 提升工作效率</h3><p>一般我们在工作中，接到开发任务后，需要新创建一个分支进行开发 此时需要 用到 <code>git branch</code>、<code>git checkout</code>、 <code>git pull</code> 等命令，在我们一顿操作后，开发完成，到了提交代码的阶段，又要诸如此类 <code>git add</code> 、<code>git commit</code>、<code>git push</code> 等命令，虽然简单，但是输入起来也是不够简洁，作为一个程序员，开发程序就是为了提高我们的效率的，懒是人类进步的源泉，所以我们可以通过配置别名的方式，简化这些命令。</p><p>它的基本用法是 <code>git config --global alias.&lt;简化的字符&gt; 原始命令</code></p><p>如下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里将 co 表示 checkout，ci 表示 commit，br 表示 branch，以后提交就可以简写成</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e4b6e415724ddbbeb85958b0e2ba05~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519152804390.png"></p><p><code>--global</code> 是全局参数，也就是配置一次后，这些命令可以在这台电脑下的所有仓库都适用。这些命令其实是更新你全局的 .gitconfig 文件，该文件用来保存全局的 git 配置，<code>vim ~/.gitconfig</code>，执行这段命令后，显示如下，下图展示了刚才通过 <code>git config --global alias</code> 添加的 <code>alias</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6abbadf7e542451f808b79a644158bf6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519153624712.png"></p><p>除了上面那种直接通过命令的方式外，也可以通过修改这个文件的 <code>alias</code> 项来设置别名。</p><p>这里分享一个我自己常用的别名设置，把以下配置替换到 .gitconfig 文件里的 <code>[alias]</code> 所属的区域，然后就可以愉快的使用了~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">st = status -sb</span><br><span class="line">co = checkout</span><br><span class="line">br = branch</span><br><span class="line">mg = merge</span><br><span class="line">ci = commit</span><br><span class="line">ds = diff --staged</span><br><span class="line">dt = difftool</span><br><span class="line">mt = mergetool</span><br><span class="line">last = log -1 HEAD</span><br><span class="line">latest = for-each-ref --sort=-committerdate --format=\&quot;%(committername)@%(refname:short) [%(committerdate:short)] %(contents)\&quot;</span><br><span class="line">ls = log --pretty=format:\&quot;%C(yellow)%h %C(blue)%ad %C(red)%d %C(reset)%s %C(green)[%cn]\&quot; --decorate --date=short</span><br><span class="line">hist = log --pretty=format:\&quot;%C(yellow)%h %C(red)%d %C(reset)%s %C(green)[%an] %C(blue)%ad\&quot; --topo-order --graph --date=short</span><br><span class="line">type = cat-file -t</span><br><span class="line">dump = cat-file -p</span><br><span class="line">lg = log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样，我们每次想查看 Git 的历史记录,就不用输入那么一长串命令 直接使用 <code>git lg</code> ，下图是 axios 源码里的提交记录，使用封装后的 <code>git lg</code> 查看的效果图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f5df1f881fa4c8fac9cc5868b35908a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image-20210519162327693.png"></p><p>分支之间的关系一眼就很明了，在哪个 commit 上进行的 merge 操作也很清晰，可以帮助我们很好的追溯历史的提交和解决问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文由浅入深的的讲解了 Git 的环境搭建，基本用法，以及工作中使用较为高频的 Git 命令的用法，无论你是前端后端还是其它端的开发，日常工作中少不了对 Git 的使用，我们不仅要会用，还要用的漂亮，用的灵活，用的稳健。这样才能在和同事协作项目的时候更加得心应手，学会了本文这些 Git 的使用技巧后，在日常工作中多多练习，相信会给你带来很大的收获！</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://link.juejin.cn/?target=https://www.ruanyifeng.com/blog/2014/06/git_remote.html" title="https://www.ruanyifeng.com/blog/2014/06/git_remote.html">阮一峰的git教程</a></p><p><a href="https://juejin.cn/post/6844903603694469134#heading-3" title="https://juejin.cn/post/6844903603694469134#heading-3">Git merge和rebase分支合并命令的区别</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://juejin.cn/post/6971586506011967519" title="https://juejin.cn/post/6971586506011967519">v8 执行 js 的过程</a></p><p><a href="https://juejin.cn/post/6968988552075952141" title="https://juejin.cn/post/6968988552075952141">手把手带你入门Webpack Plugin</a></p><h2 id="开源作品"><a href="#开源作品" class="headerlink" title="开源作品"></a>开源作品</h2><ul><li>  政采云前端小报</li></ul><p><strong>开源地址 <a href="https://link.juejin.cn/?target=https://www.zoo.team/openweekly/" title="https://www.zoo.team/openweekly/">www.zoo.team/openweekly/</a></strong> (小报官网首页有微信交流群)</p><h2 id="招贤纳士"><a href="#招贤纳士" class="headerlink" title="招贤纳士"></a>招贤纳士</h2><p>政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 40 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。</p><p>如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 <code>ZooTeam@cai-inc.com</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2cd4a6446934dbc9144a60ee4f82e59~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
    <category term="代码管理工具" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【转载】如何封装一个高质量的表单通用组件？ - 掘金</title>
    <link href="http://example.com/posts/undefined/"/>
    <id>http://example.com/posts/undefined/</id>
    <published>2023-03-02T02:15:38.710Z</published>
    <updated>2023-03-02T02:16:42.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p><strong>开启掘金成长之旅！这是我参与「掘金日新计划 · 2 月更文挑战」的第 8 天，<a href="https://juejin.cn/post/7194721470063312933" title="https://juejin.cn/post/7194721470063312933">点击查看活动详情</a></strong></p><p>我们都知道表单组件应该是后台管理系统中用得最多的组件，我们不可能每个业务都写一次表单，然后每一次修改都去各自业务中大幅修改，这样就可能导致代码重复率太高了，工作效率频频降低，所以我们需要封装起来，这样我们就可以复用，<code>大大减少项目体积，方便项目的后期维护，提高前端娃的工作效率</code>。由于我们使用表单都是直接使用UI组件库的组件，所以我们需要做<code>二次封装</code>，那么问题来了，二次封装表单组件我们需要考虑什么？</p><blockquote><p>本文基于Element-plus实现二次封装表单组件。</p></blockquote><ul><li>  <strong>特性复用</strong>：必须继承原有组件的<code>所有特性</code>。</li><li>  <strong>命名规范</strong>：二次组件名必须<code>见名知意</code>，我们一般都是起一个<strong>公用名+原有组件名</strong>，比如<code>lib-form</code>。</li><li>  <strong>接口简单</strong>：自定义暴露出来的<code>接口越简单</code>越好。</li><li>  <strong>容易拓展</strong>：留有<code>自定义插槽</code>，让用户可以自己选择。</li><li>  <strong>功能完善</strong>：具备更<code>完善的功能</code>如：表单验证、动态删减表单，集成第三方的插件（富文本）…</li><li>  <strong>场景通用</strong>：具备<code>多个场景使用</code>，比如弹框嵌套表单、页面嵌套表单。</li></ul><p>封装一个高质量的通用组件，上面是真的只是基操，话不多说，直接上实践手把手教你封装组件。</p><p><strong>步骤1️⃣</strong>：继承原有组件的所有特性（<strong>这也是封装的核心</strong>）。先明确三个大方向：</p><ul><li><code>表单</code>固定属性，继承Form表单的所有属性、方法。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 定义el-form的ref继承原有组件的form属性</span><br><span class="line"> export interface FormInstance &#123;</span><br><span class="line">  registerLabelWidth(width: number, oldWidth: number): void,</span><br><span class="line">  deregisterLabelWidth(width: number): void,</span><br><span class="line">  autoLabelWidth: string | undefined,</span><br><span class="line">  emit: (evt: string, ...args: any[]) =&gt; void,</span><br><span class="line">  labelSuffix: string,</span><br><span class="line">  inline?: boolean,</span><br><span class="line">  model?: Record&lt;string, unknown&gt;,</span><br><span class="line">  size?: string,</span><br><span class="line">  showMessage?: boolean,</span><br><span class="line">  labelPosition?: string,</span><br><span class="line">  labelWidth?: string,</span><br><span class="line">  rules?: Record&lt;string, unknown&gt;,</span><br><span class="line">  statusIcon?: boolean,</span><br><span class="line">  hideRequiredAsterisk?: boolean,</span><br><span class="line">  disabled?: boolean,</span><br><span class="line">  validate: (callback?: Callback) =&gt; Promise&lt;boolean&gt;,</span><br><span class="line">  resetFields: () =&gt; void,</span><br><span class="line">  clearValidate: (props?: string | string[]) =&gt; void,</span><br><span class="line">  validateField: (props: string | string[], cb: ValidateFieldCallback) =&gt; void,</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><code>表单项</code>固定属性，继承表单项的所有属性、方法。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 表单每一项的配置选项</span><br><span class="line">export interface FormOptions &#123;</span><br><span class="line">  // 表单项显示的元素</span><br><span class="line">  type: &#x27;&#x27;,// 定义表单项类型</span><br><span class="line">  value?: any, // 表单项的值</span><br><span class="line">  label?: string,// 表单项label</span><br><span class="line">  prop?: string,// 表单项的标识</span><br><span class="line">  rules?: RuleItem[],// 表单项的验证规则</span><br><span class="line">  placeholder?: string,// 表单项的占位符</span><br><span class="line">  attrs?: &#123;  // 按需定义不同表单类型属性</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line">  children?: FormOptions[],// 表单项的子元素，可能存在嵌套表单组件，如select</span><br><span class="line">  ....// 适当扩展我们需要的属性，比如上传组件属性，行布局表单属性</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>由于Element-plus组件都是以<code>el-</code>为前缀，所以type取值只需要取<code>el-后面部分</code>作为值就行，比如el-input取 <strong>‘input’</strong> 为值。</p></blockquote>  <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f06de387d4b4c3993281410f8c05287~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></li><li>表单验证效果，继承组件原有的所有验证属性。由于Element-plus的验证都是使用 <strong><a href="https://link.juejin.cn/?target=https://github.com/yiminghe/async-validator" title="https://github.com/yiminghe/async-validator">async-validator</a></strong> 这个插件的验证方法，直接复用插件源码路径async-validator/src/interface.ts文件下的所有代码：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 核心代码：封装验证方式时的属性</span><br><span class="line">export interface RuleItem &#123;</span><br><span class="line">  type?: RuleType; // 验证种类</span><br><span class="line">  required?: boolean;// 是否必填</span><br><span class="line">  pattern?: RegExp | string;// 验证方式匹配</span><br><span class="line">  min?: number; // 表单项最小值</span><br><span class="line">  max?: number; // 表单项最大值</span><br><span class="line">  len?: number; // 表单项字符长度</span><br><span class="line">  trigger?: string | string[];// 验证触发方式</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>步骤2️⃣</strong>：实现一个完善的通用组件封装，通过对标签封装、接口暴露、开发者传参等。明确表单类型，根据不同类型表单复用多种场景，不仅开发者用户拓展，而且，让开发者用最少代码就可以复用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--表单框架：model就是传入的表单对象，rules就是传入的验证对象 --&gt;</span><br><span class="line">  &lt;el-form</span><br><span class="line">    v-if=&quot;model&quot;</span><br><span class="line">    :validate-on-rule-change=&quot;false&quot;</span><br><span class="line">    v-bind=&quot;$attrs&quot;</span><br><span class="line">    :model=&quot;model&quot;</span><br><span class="line">    :rules=&quot;rules&quot;</span><br><span class="line">    ref=&quot;form&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    ... &lt;!--表单项封装 --&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>普通表单项封装</strong>，比如日期、输入等组件。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-for=&quot;(item, index) in options&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;el-form-item  :label=&quot;item.label&quot; :prop=&quot;item.prop&quot;&gt;</span><br><span class="line">      &lt;component</span><br><span class="line">        v-else</span><br><span class="line">        :is=&quot;`el-$&#123;item.type&#125;`&quot;</span><br><span class="line">        v-bind=&quot;item.attrs&quot;</span><br><span class="line">        v-model=&quot;model[item?.prop!]&quot;</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;/component&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><strong>嵌套表单项封装</strong>，比如下拉框，除了select组件还嵌套option组件。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-for=&quot;(item, index) in options&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;el-form-item</span><br><span class="line">      v-if=&quot;item.children &amp;&amp; item.children.length&quot;</span><br><span class="line">      :label=&quot;item.label&quot;</span><br><span class="line">      :prop=&quot;item.prop&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;component</span><br><span class="line">        :is=&quot;`el-$&#123;item.type&#125;`&quot;</span><br><span class="line">        v-bind=&quot;item.attrs&quot;</span><br><span class="line">        v-model=&quot;model[item?.prop!]&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;component</span><br><span class="line">          v-for=&quot;(child, i) in item.children&quot;</span><br><span class="line">          :key=&quot;i&quot;</span><br><span class="line">          :label=&quot;child.label&quot;</span><br><span class="line">          :value=&quot;child.value&quot;</span><br><span class="line">          :is=&quot;`el-$&#123;child.type&#125;`&quot;</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;/component&gt;</span><br><span class="line">      &lt;/component&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><strong>富文本表单项封装</strong>，本文使用的是wangEditor。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;editor&quot; v-else-if=&quot;item.type === &#x27;editor&#x27;&quot;&gt;&lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import E from &#x27;wangeditor&#x27;;</span><br><span class="line">// 遍历传入的prop的options对象，初始化富文本</span><br><span class="line">if (item.type === &#x27;editor&#x27;) &#123;</span><br><span class="line">// 初始化富文本</span><br><span class="line">nextTick(() =&gt; &#123;</span><br><span class="line">  if (document.getElementById(&#x27;editor&#x27;)) &#123;</span><br><span class="line">    const editor = new E(&#x27;#editor&#x27;);</span><br><span class="line">    editor.config.placeholder = item.placeholder!;</span><br><span class="line">    editor.create();</span><br><span class="line">    // 初始化富文本的内容</span><br><span class="line">    editor.txt.html(item.value);</span><br><span class="line">    editor.config.onchange = (newHtml: string) =&gt; &#123;</span><br><span class="line">      model.value[item.prop!] = newHtml;</span><br><span class="line">    &#125;;</span><br><span class="line">    edit.value = editor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><strong>上传表单项封装</strong>：向开发者暴露上传的核心方法：预览、删除、上传成功等，同时允许开发者自定义上传信息以及渲染区域等。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-form-item  :label=&quot;item.label&quot; :prop=&quot;item.prop&quot;&gt;</span><br><span class="line">  &lt;!-- 上传表单 --&gt;</span><br><span class="line">  &lt;el-upload</span><br><span class="line">    v-if=&quot;item.type === &#x27;upload&#x27;&quot;</span><br><span class="line">    v-bind=&quot;item.uploadAttrs&quot;</span><br><span class="line">    :on-preview=&quot;onPreview&quot;</span><br><span class="line">    :on-remove=&quot;onRemove&quot;</span><br><span class="line">    :on-success=&quot;onSuccess&quot;</span><br><span class="line">    :on-error=&quot;onError&quot;</span><br><span class="line">    :on-progress=&quot;onProgress&quot;</span><br><span class="line">    :on-change=&quot;onChange&quot;</span><br><span class="line">    :before-upload=&quot;beforeUpload&quot;</span><br><span class="line">    :before-remove=&quot;beforeRemove&quot;</span><br><span class="line">    :http-request=&quot;httpRequest&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;slot name=&quot;uploadArea&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;uploadTip&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/el-upload&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><strong>同行多个表单布局封装</strong>：有时业务需要，一行可以定义多个表单，所以需要使用el-row，此时需要修改FormOptions属性接口，完善多个表单场景，cols是一个数组定义FormOptions数组，colOption是<code>el-col组件的相关属性</code>，然后重新复用嵌套表单的代码。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template v-if=&quot;item.type === &#x27;row&#x27;&quot;&gt;</span><br><span class="line">    &lt;el-row :gutter=&quot;item.rowGutter&quot;&gt;</span><br><span class="line">    &lt;el-col</span><br><span class="line">    v-for=&quot;(jtem, jndex) in item.cols&quot;</span><br><span class="line">    v-bind=&quot;jtem.colOption&quot;</span><br><span class="line">    :key=&quot;jndex&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;el-form-item :label=&quot;jtem.label&quot; :prop=&quot;jtem.prop&quot;&gt;</span><br><span class="line">      &lt;component</span><br><span class="line">        :is=&quot;`el-$&#123;jtem.type&#125;`&quot;</span><br><span class="line">        v-bind=&quot;jtem.attrs&quot;</span><br><span class="line">        v-model=&quot;model[jtem?.prop!]&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;template v-if=&quot;jtem.children &amp;&amp; jtem.children.length&quot;&gt;</span><br><span class="line">          &lt;component</span><br><span class="line">            v-for=&quot;(child, i) in jtem.children&quot;</span><br><span class="line">            :key=&quot;i&quot;</span><br><span class="line">            :label=&quot;child.label&quot;</span><br><span class="line">            :value=&quot;child.value&quot;</span><br><span class="line">            :is=&quot;`el-$&#123;child.type&#125;`&quot;</span><br><span class="line">          &gt;</span><br><span class="line">          &lt;/component&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/component&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><strong>自定义插槽</strong>：开发者可以根据需要，在封装的el-form中添加插槽，可以允许组件功能的拓展，我们可以根据自己需要进行封装，这里就不一一演示了。</li><li><strong>提交取消按钮区域</strong>：这个最好可以实现插槽让开发者可以自定义。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-form-item&gt;</span><br><span class="line">      &lt;slot name=&quot;action&quot; :form=&quot;form&quot; :model=&quot;model&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>步骤3️⃣</strong>：开发者的调用封装组件，通过配置不同表单类型的数组，然后调用lib-form封装组件实现业务代码复用。</p><ul><li><strong>组件的调用</strong>：根据业务需要，可以适当定义我们需要的组件属性以及必须要传的参数。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;lib-form</span><br><span class="line">  ref=&quot;form&quot;</span><br><span class="line">  label-width=&quot;100px&quot;</span><br><span class="line">  :options=&quot;options&quot;</span><br><span class="line">  @on-change=&quot;handleChange&quot;</span><br><span class="line">  @before-upload=&quot;handleBeforeUpload&quot;</span><br><span class="line">  @on-preview=&quot;handlePreview&quot;</span><br><span class="line">  @on-remove=&quot;handleRemove&quot;</span><br><span class="line">  @before-remove=&quot;beforeRemove&quot;</span><br><span class="line">  @on-success=&quot;handleSuccess&quot;</span><br><span class="line">  @on-exceed=&quot;handleExceed&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;template #uploadArea&gt;</span><br><span class="line">    &lt;el-button size=&quot;small&quot; type=&quot;primary&quot;&gt;Click to upload&lt;/el-button&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template #uploadTip&gt;</span><br><span class="line">    &lt;div style=&quot;color: #ccc; font-size: 12px&quot;&gt;</span><br><span class="line">      jpg/png files with a size less than 500kb</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template #action=&quot;scope&quot;&gt;</span><br><span class="line">    &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(scope)&quot;&gt;提交&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button @click=&quot;resetForm&quot;&gt;重置&lt;/el-button&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/lib-form&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><strong>表单项的配置数组</strong>：由于这配置数组比较长，所以一般可以单独抽离出来，不要写在vue文件中，这样可以提高代码的可读性。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这里以多行表单布局为例子</span><br><span class="line">let options: FormOptions[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    type: &#x27;row&#x27;,</span><br><span class="line">    rowGutter: 20,</span><br><span class="line">    cols: [</span><br><span class="line">      &#123;</span><br><span class="line">        type: &#x27;input&#x27;,</span><br><span class="line">        value: &#x27;&#x27;,</span><br><span class="line">        label: &#x27;用户名&#x27;,</span><br><span class="line">        prop: &#x27;username&#x27;,</span><br><span class="line">        placeholder: &#x27;请输入用户名&#x27;,</span><br><span class="line">        rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            required: true,</span><br><span class="line">            message: &#x27;用户名不能为空&#x27;,</span><br><span class="line">            trigger: &#x27;blur&#x27;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            min: 2,</span><br><span class="line">            max: 6,</span><br><span class="line">            message: &#x27;用户名在2-6位之间&#x27;,</span><br><span class="line">            trigger: &#x27;blur&#x27;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        attrs: &#123;</span><br><span class="line">          clearable: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        colOption: &#123;</span><br><span class="line">          offset: 0,</span><br><span class="line">          span: 12,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        type: &#x27;input&#x27;,</span><br><span class="line">        value: &#x27;&#x27;,</span><br><span class="line">        label: &#x27;用户名&#x27;,</span><br><span class="line">        prop: &#x27;username&#x27;,</span><br><span class="line">        placeholder: &#x27;请输入用户名&#x27;,</span><br><span class="line">        rules: [</span><br><span class="line">          &#123;</span><br><span class="line">            required: true,</span><br><span class="line">            message: &#x27;用户名不能为空&#x27;,</span><br><span class="line">            trigger: &#x27;blur&#x27;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            min: 2,</span><br><span class="line">            max: 6,</span><br><span class="line">            message: &#x27;用户名在2-6位之间&#x27;,</span><br><span class="line">            trigger: &#x27;blur&#x27;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        attrs: &#123;</span><br><span class="line">          clearable: true,</span><br><span class="line">        &#125;,</span><br><span class="line">        colOption: &#123;</span><br><span class="line">          offset: 0,</span><br><span class="line">          span: 12,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"> ]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结</strong>：UI组件二次封装其实不难，只要我们能掌握基本语法，就可以根据业务场景去封装我们需要的组件，然后在慢慢去完善这个组件的功能。只要遵循这些原则：<strong>命名规范、组件通用、特性继承、场景通用、接口简单、兼容性强、功能完善。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>【转载】前端项目集成Vite配置一览无余！ - 掘金</title>
    <link href="http://example.com/posts/undefined/"/>
    <id>http://example.com/posts/undefined/</id>
    <published>2023-03-02T02:08:59.268Z</published>
    <updated>2023-03-02T02:16:46.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h2 id="Vite配置文件"><a href="#Vite配置文件" class="headerlink" title="Vite配置文件"></a>Vite配置文件</h2><ul><li>  <strong>默认指定</strong>：<code>vite.config.js</code>。</li><li>  <strong>自定义指定</strong>：<code>vite --config 自定义名称.js</code>。</li></ul><h2 id="Vite相关命令"><a href="#Vite相关命令" class="headerlink" title="Vite相关命令"></a>Vite相关命令</h2><ul><li>  <strong>查看Vite有哪些命令</strong>：<code>npx vite -help</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--host [host]// 指定域名</span><br><span class="line">--port &lt;port&gt;// 指定端口</span><br><span class="line">--https // 使用 TLS+HTTP/2</span><br><span class="line">--cors // 可以跨域</span><br><span class="line">--open [path] // 启动自动打开服务器</span><br><span class="line">--stictPort // 如果指定端口被使用退出程序</span><br><span class="line">--force // 强制Vite重新执行预构建，忽视缓存</span><br><span class="line">--config | -c  &lt;file&gt; // 指定vite的配置文件</span><br><span class="line">--base path // 指定url读取文件基本路径</span><br><span class="line">--clearScreen // 日志记录时，是否清屏</span><br><span class="line">--logLevel | -l &lt;level&gt; // 指定日志等级：error|info|silent|warn</span><br><span class="line">--debug | -d  &lt;feat&gt;  // 获取调试日志</span><br><span class="line">--filter | -f &lt;filter&gt; // 过滤调试日志</span><br><span class="line">--mode | -m &lt;mode&gt; // 设置env模式</span><br><span class="line">--help | -h // 获取vite帮助信息</span><br><span class="line">--version | -v // 获取vite版本信息</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p><strong>什么时候需要使用–force？</strong></p><p>Vite缓存分为两部分：</p><p>文件系统缓存：Vite会将预构建的依赖缓存到node_modules/.vite，package.json的dependencies字段和依赖lock文件，或者vite.config中相关字段配置过的，这些文件发生变化，vite就会重新构建，强制执行可以通过<code>--force</code> 或<code>手动删除.vite目录</code>。</p><p>浏览器缓存：解析后的依赖请求会以http头max-age=<code>max-age=31536000,immutable</code> 强缓存，提高开发页面重载性能。</p></blockquote><ul><li>  <strong>vite命令有哪些</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vite [root]  // 启动以配置文件root为入口的项目开发环境</span><br><span class="line">vite serve // 启动以配置文件root为入口的项目开发环境</span><br><span class="line">vite build [root] // 打包以配置文件root为入口的文件为生产环境文件</span><br><span class="line">vite optimize [root] // 预构建生产环境</span><br><span class="line">vite preview [root] // 构建一个本地预览静态生产环境</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>preview是没有热更新的，当程序修改不会实时更新页面，需要重新执行命令。因为这个环境是生产环境，类似于上线项目，需要重新构建才能获取修改的功能。</p></blockquote><ul><li>  <strong>pageage.json文件里配置vite命令</strong>：</li></ul><blockquote><p><strong>--noEmit</strong>的作用是只进行检查，不进行编译输出，这个属性也可以在tsconfig.json文件中指定；<strong>--open</strong>项目启动自动打开浏览器。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;vite --open&quot;,</span><br><span class="line">&quot;serve&quot;: &quot;vite serve&quot;,</span><br><span class="line">&quot;build&quot;: &quot;vue-tsc --noEmit&amp;&amp; vite build&quot;,</span><br><span class="line">&quot;staging&quot;: &quot;vue-tsc &amp;&amp; vite build --mode development&quot;,</span><br><span class="line">&quot;preview&quot;: &quot;vue-tsc &amp;&amp; vite preview&quot;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="配置环境模式"><a href="#配置环境模式" class="headerlink" title="配置环境模式"></a>配置环境模式</h2><p><strong>默认环境</strong>：当pageage.json中的script字段里的命令执行了<code>vite serve</code>或 <code>vite</code>，vite默认是开发环境（<code>development</code>），当执行了<code>vite build</code>命令，vite默认环境为生产环境（<code>production</code>）。注意地，当执行地是<code>vite preview</code>命令，vite默认环境也是生产环境，因为这个命令主要是创建一个能在本地执行的生产环境。JavaScript模块有一个暴露特定上下文元数据属性的对象（<code>import.meta</code>），这个对象包含了当前模块的信息，对象里有三个属性：<strong>env（环境变量）</strong>、<strong>resolve</strong>、<strong>url（当前模块加载路径）</strong>，因为在main.ts打印的信息，所以这里获取的路径是src/main.ts。</p><blockquote><p>在库模式下，也就是打包为一个库供其他开发人员下载引用的情况下，所有<code>import.meta.env.*</code>的用法在构建时会被静态替换，也就是使用的时候必须按 <code>import.meta.env.BASE_URL</code> 的原样出现（例如 <code>import.meta.env[&#39;BASE_URL&#39;]</code> 是无效的）。但<code>process.env.*</code>不会被替换，库的使用者可以动态修改它。如果不希望这样做，可以在配置中配置：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define:&#123;</span><br><span class="line">  ` &#x27;process.env.NODE_ENV&#x27;: &#x27;&quot;production&quot;&#x27;`;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdd3f374504e4f80a670fcce1b862912~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.ts</span><br><span class="line">console.log(import.meta);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中的env环境变量默认也有5个属性：<strong>BASE_URL</strong>（url公共路径）、<strong>DEV</strong>（是开发模式）、<strong>PROD</strong>（是否生产模式）、<strong>mode</strong>（环境模式）、<strong>SSR</strong>（是否服务器渲染）。当项目还配置有自定义环境变量时，env环境中自定义变量也会带上的。</p><blockquote><p>注意：如果自定义环境变量前缀必须为**VITE_**因为vite配置文件中的envPrefix属性值默认为VITE_。如果想改变成自定义，在配置文件中必须配置envPrefix。</p></blockquote><p><strong>自定义环境</strong>：通过创建相应模式的文件。文件名格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.env  // 所有模式都会加载</span><br><span class="line">.env.local // 所有模式都会加载，但会被git忽略</span><br><span class="line">.env.[mode].local // 只有特定模式会加载，但会被git忽略</span><br><span class="line">.env.[mode] // 只有指定模式会加载，注意.env.production优先级比.env高</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>配置指定环境模式</strong>：通过在vite.config.js文件中的基本配置中的mode属性指定，在这里指定会覆盖掉vite serve 、vite build中的默认mode模式，注意地，这个vite preview中mode不会被覆盖，还有如果在命令中指定mode，比如<strong>vite serve –mode production</strong>，这样也不会被配置文件中地mode覆盖，也就是<code>命令行指定mode优先级最高</code>。</p><h2 id="兼容设置"><a href="#兼容设置" class="headerlink" title="兼容设置"></a>兼容设置</h2><p><strong>模块导入兼容</strong>：支持原生ESM script标签、原生ESM 动态导入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// vite.config.js</span><br><span class="line">build:&#123;</span><br><span class="line">  target:&#x27;es2015&#x27;,// 支持es6文件</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>浏览器兼容</strong>：兼容低版本浏览器，需要安装：<code>yarn add @vitejs/plugin-legacy -D</code> vite.config.js中的plugins配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// vite.config.js</span><br><span class="line">import legacyPlugin form &#x27;@vitejs/plugin-legacy&#x27;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">    legacyPlugin(&#123;</span><br><span class="line">    targets:[&#x27;chrome 52&#x27;], // 需要兼容的目标浏览器列表，可以设置多个</span><br><span class="line">    additionalLegacyPolyfills:[&#x27;regenerator-runtime/runtime&#x27;] // 面向IE11时需要此插件</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="项目适配处理"><a href="#项目适配处理" class="headerlink" title="项目适配处理"></a>项目适配处理</h2><h3 id="对样式的处理"><a href="#对样式的处理" class="headerlink" title="对样式的处理"></a>对样式的处理</h3><p><strong>预处理器的处理</strong>：由于Vite内置了对预处理器的支持，使用预处理器<code>只需要安装对应的预处理器就可以</code>，再也不需要安装相应预处理器加载器了，也不需要在vite配置了。比如使用less预处理器，这里只需要下载less就行。</p><p><strong>css Modules</strong>：在不同模块中定义相同类名，会导致样式被覆盖，这时候就要用到CSS module。以.module.css结尾的文件都会被认为是一个css modules文件。导入这样文件会返回一个相应对象。这样就不会产生样式冲突被覆盖，因为每一个module都是一个独立css文件，也就是模块化。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* example1.module.css */</span><br><span class="line">.exampleClass&#123;</span><br><span class="line">    color:green;</span><br><span class="line">&#125;</span><br><span class="line">/* example2.module.css */</span><br><span class="line">.exampleClass&#123;</span><br><span class="line">    color:blue;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.ts</span><br><span class="line">import example1 from &#x27;@/common/styles/example1.module.css&#x27;</span><br><span class="line">import example2  from &#x27;@/common/styles/example2.module.css&#x27;</span><br><span class="line">console.log(example1.exampleClass); // _exampleClass_16yyc_1</span><br><span class="line">console.log(example2.exampleClass); // _exampleClass_tc6yz_1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Vite中css modules配置有5个属性：</p><ul><li><code>localsConvention</code>：模块化后的css类名命名规则，驼峰还是划线</li><li><code>scopeBehaviour</code>：配置当前模块行为是模块化还是全局化（标签上带有hash就是开启了模块化）有点类似是否style标签是否配置了scoped，如下图中去掉scoped就是全局化了，去掉scoped标签上就没有data-v-hash值。</li><li><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/576a1d35bfaa4eaaa09c93e8c6b148bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"> 而这里是控制的是<strong>css modules文件</strong>的模块行为。如果这个属性配置了global，这个模块文件样式全局生效，上面的打印都是为undefined。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// main.ts</span><br><span class="line">import example1 from &#x27;@/common/styles/example1.module.css&#x27;</span><br><span class="line">import example2  from &#x27;@/common/styles/example2.module.css&#x27;</span><br><span class="line">console.log(example1.exampleClass); // undefined</span><br><span class="line">console.log(example2.exampleClass); // undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li><li><strong>generateScopedName</strong>:如[name]_[local]_[hash:5]，模块对象生成的类名的规则，默认值是不带name。</li><li><strong>hashPrefix</strong>：hash是根据文件名类名等生成的，这个前缀可以使生成的hash更加复杂独特。</li><li><strong>globalModulePaths</strong>：想要参加到css模块化的文件路径数组。</li></ul><p><strong>postcss处理</strong>：使用postcss插件对css代码进行转换。postscss是什么？一个用JavaScript工具和插件转换css代码地工具。使用postcss相关插件可以支持css使用高级语法、样式浏览器兼容（添加兼容前缀），比如在css中使用变量var，Vite里postcss配置默认支持css变量，如果需要支持添加兼容，需要安装<code>postcss-preset-env</code>插件，并在postcss配置引入插件，代码解析时就会自动添加兼容前缀</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:root&#123;</span><br><span class="line">    --color:green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.example&#123;</span><br><span class="line">    color:var(--color,blue);/* 找不到--color这个变量就是使用后面的值*/</span><br><span class="line">    user-select: none;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">安装了postcss-preset-env ，会自动加上前缀</span><br><span class="line"> -webkit-user-select: none; </span><br><span class="line"> -moz-user-select: none; </span><br><span class="line"> user-select: none;</span><br><span class="line">*/</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Vite中配置css：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">css: &#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    localsConvention:&#x27;camelCaseOnly&#x27;,</span><br><span class="line">    scopeBehaviour:&#x27;local&#x27;,</span><br><span class="line">    generateScopedName:&#x27;[name]_[local]_[hash:5]&#x27;,</span><br><span class="line">    hashPrefix:&#x27;&#x27;,</span><br><span class="line">    globalModulePaths:[]</span><br><span class="line">  &#125;,</span><br><span class="line">  postcss: &#123;</span><br><span class="line">    plugins:[postcssPreset()],</span><br><span class="line">  &#125;,</span><br><span class="line">  preprocessorOptions: &#123;</span><br><span class="line">    less: &#123;</span><br><span class="line">      additionalData: &#x27;@import &quot;./src/common/styles/index.less&quot;;&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  devSourcemap: true,// 开发过程中是否启用css sourcemap</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="对typescript处理"><a href="#对typescript处理" class="headerlink" title="对typescript处理"></a>对typescript处理</h3><ul><li>  <strong>安装依赖</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add typescript -D   // 安装typescript</span><br><span class="line">yarn add vite-plugin-checker -D // ts代码检查插件</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>  <strong>vite配置</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins: [checker(&#123;</span><br><span class="line">    typescript:true</span><br><span class="line">&#125;)],</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>  <strong>tsconfig.json配置</strong>：在 <code>tsconfig.json</code> 中的 <code>compilerOptions</code> 下设置 <code>&quot;isolatedModules&quot;: true</code>。如此做，TS 会警告你不要使用隔离（isolated）转译的功能。因为<code>esbuild</code> 只执行没有类型信息的转译，它并不支持某些特性，如 <code>const enum</code> 和隐式类型导入。</li></ul><h3 id="对静态资源处理"><a href="#对静态资源处理" class="headerlink" title="对静态资源处理"></a>对静态资源处理</h3><ul><li>  vite对静态资源的处理大大提供了引入格式的支持，通过对引入路径<strong>添加参数后缀</strong>，资源引入为url（<code>?url</code>）、显示url引入、导入脚本为worker（<code>?worker或?sharedworker</code>）、将资源引入为字符串（<code>?raw</code>）。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Worker from &#x27;./worker?worker&#x27; // 引入为一个worker</span><br><span class="line">import imgUrl from &#x27;./assets/316149.jpg&#x27; //引入为一个资源路径 ，imgUrl的值为/src/assets/316149.jpg</span><br><span class="line">import assetAsURL from &#x27;./assets/asset.js?url&#x27; //引入资源为url， assetAsURL的值为/src/assets/asset.js</span><br><span class="line">import assetAsstring from &#x27;./assets/asset.js?raw&#x27; //引入资源为字符串，这里assetAsstring的值为js文件所有内容的字符串</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="对JSON文件导入处理"><a href="#对JSON文件导入处理" class="headerlink" title="对JSON文件导入处理"></a>对JSON文件导入处理</h3><p>Vite中提供了对JSON文件解析的支持，当我们引入json文件的时候，Vite会帮我们转化一下JSON格式为对象格式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// &#123;&quot;a&quot;:&quot;1&quot;&#125;</span><br><span class="line">import jsonFile from &#x27;./assets/example.json&#x27;</span><br><span class="line">console.log(jsonFile);// &#123;a:&quot;1&quot;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="对Vue、React处理"><a href="#对Vue、React处理" class="headerlink" title="对Vue、React处理"></a>对Vue、React处理</h3><p>如果在Vue或React项目中使用Vite我们需要引入相应插件适配对应框架：如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Vue3：@vitejs/plugin-vue</span><br><span class="line">// Vue3 JSX：@vitejs/plugin-jsx</span><br><span class="line">// Vue2.7：@vitejs/vite-plugin-vue2</span><br><span class="line">// Vue&lt;2.7：underfin/vite-plugin-vue2</span><br><span class="line"></span><br><span class="line">// React：@vitejs/plugin-react</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="常见基本配置"><a href="#常见基本配置" class="headerlink" title="常见基本配置"></a>常见基本配置</h2><p>defineConfig的配置参数格式：对象、promise回调函数、配置方法。当defineConfig为配置方法时，它的参数为一个包含三个属性的对象：command（执行命令，有serve|build）、mode（环境模式）、ssrBuild（是否为服务器渲染构建）。在Vite配置中如果有些配置需要通过command或mode来控制时，这个配置方法就使用的上了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// __dirname需要安装@types/node</span><br><span class="line">// 也可以使用process.cwd() 代表程序执行目录，也就是项目根目录</span><br><span class="line">const resolve = (dir: string) =&gt; path.resolve(__dirname, dir);</span><br><span class="line">export default defineConfig((&#123; command, mode &#125;) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">   // Vite配置</span><br><span class="line">   root: &#x27;./&#x27;,// 入口文件位置，如index.html</span><br><span class="line">   base: &#x27;./&#x27;,// 启动服务公共路径</span><br><span class="line">   publicDir: resolve(&#x27;public&#x27;),// 静态资源路径</span><br><span class="line">   mode: &#x27;production&#x27;, // 指定mode，会覆盖掉serve和build默认的mode</span><br><span class="line">   cacheDir: &#x27;node_modules/.vite&#x27;,// 默认vite缓存路径</span><br><span class="line">   logLevel: &#x27;warn&#x27;,// 控制台输出的级别，error|info|silent|warn 默认 info 那么所有的日志都会打印出来</span><br><span class="line">   esbuild：&#123;</span><br><span class="line">        jsxFactory: &#x27;h&#x27;,</span><br><span class="line">        jsxFragment: &#x27;Fragment&#x27; 以上为自定义JSX</span><br><span class="line">        // ESbuild会被应用在 ts、jsx、tsx 文件，以下选项对要处理的文件类型进行配置</span><br><span class="line">        include：string | RegExp | (string | RegExp)[]</span><br><span class="line">        exclude：string | RegExp | (string | RegExp)[]</span><br><span class="line">        jsxInject:`import React from &#x27;react&#x27;`// 自动为每一个被 ESbuild 转换的文件注入内容</span><br><span class="line">    &#125;</span><br><span class="line">   clearScreen: true,// 控制台是否清屏，最好不要设置，设置会屏蔽掉一些关键终端信息</span><br><span class="line">   envDir: &#x27;&#x27;,// 加载存放.env文件的目录</span><br><span class="line">   envPrefix: &#x27;VITE_&#x27;,// 默认VITE_， 设置环境变量的前缀</span><br><span class="line">   appType: &#x27;spa&#x27;,// 应用种类 spa | mpa | custom</span><br><span class="line">   assetsInclude: [&#x27;&#x27;],// 支持的其他类型文件都可以在这里找到</span><br><span class="line">   plugins: [vue(),checker(&#123;typescript:true&#125;)],</span><br><span class="line">   css:&#123;&#125;,</span><br><span class="line">   resolve: &#123;</span><br><span class="line">       alias: &#123;</span><br><span class="line">         &quot;@&quot;: resolve(&#x27;src&#x27;),// 简化引用路径，用@代替</span><br><span class="line">       &#125;,</span><br><span class="line">       dedupe: [],// 强制Vite始终将列出的依赖项解析为同一副本（从项目根目录）</span><br><span class="line">       conditions: [],// 解析pageage.json中情景导出时的其他允许条件，如exports字段中的import和require为情景</span><br><span class="line">       mainFields: [],// 解析包的入口点时尝试的字段列表</span><br><span class="line">       extensions: [],// 导入时想要省略的扩展名列表</span><br><span class="line">       preserveSymlinks: false,// </span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  json: &#123;</span><br><span class="line">      namedExports: true,// 是否支持从.json文件中进行按名导入</span><br><span class="line">      stringify: false,// 导入的json转换为export default JSON.parse(&quot;...&quot;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 服务器相关</span><br><span class="line">  server:&#123;</span><br><span class="line">    ....</span><br><span class="line">    //服务器代理</span><br><span class="line">      proxy: &#123;</span><br><span class="line">        &#x27;/api&#x27;: &#123;</span><br><span class="line">          target: &#x27;http://127.0.0.1:2022&#x27;,</span><br><span class="line">          // changeOrigin: true,// 代理时，host默认浏览器的host，为true，host为target的值</span><br><span class="line">          // rewrite:path=&gt;path.replace(/^\/adc/,&#x27;&#x27;)  // 重写url路径</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   ...</span><br><span class="line">  &#125;,</span><br><span class="line">  build: &#123;</span><br><span class="line">  manifest: false,// 是否生成一个 manifest.json 的文件在assets目录下</span><br><span class="line">  target: &#x27;modules&#x27;,</span><br><span class="line">  outDir: mode === &#x27;staging&#x27; ? &#x27;bundle&#x27; : &#x27;dist&#x27;,</span><br><span class="line">  modulePreload: true,// 是否动态引入polyfill，需要引入兼容性相关的文件</span><br><span class="line">  assetsDir: &#x27;assets&#x27;,// 指定打包生成静态资源的存放路径</span><br><span class="line">  assetsInlineLimit: 4096,// 默认4kb 配置图片编译base64时大小，大于以原文件引入，小于会直接编译</span><br><span class="line">  chunkSizeWarningLimit: 500,// 打包文件超大小警告显示，默认500kbs</span><br><span class="line">  emptyOutDir: true,// 构建时是否清空OutDir，再把新构建的文件放进去</span><br><span class="line">  watch: [&#x27;&#x27;], // 监听文件变化，如果启动build不会退出程序,</span><br><span class="line">  sourcemap:false,// 构建后是否生成 source map 文件</span><br><span class="line">  ....</span><br><span class="line">&#125;,</span><br><span class="line">  ssr:&#123;&#125;,// 服务器渲染配置</span><br><span class="line">  preview:&#123;&#125;,// 预览生产环境配置</span><br><span class="line">  worker:&#123;&#125;,// worker线程相关配置</span><br><span class="line">  optimizeDeps:&#123;&#125;,// 依赖优化配置</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://link.juejin.cn/?target=https://cn.vitejs.dev/" title="https://cn.vitejs.dev/"># Vite官方中文文档</a></p><p><a href="https://link.juejin.cn/?target=https://blog.csdn.net/weixin_43294560/article/details/123280642" title="https://blog.csdn.net/weixin_43294560/article/details/123280642"># vite 基础配置</a></p><p><a href="https://link.juejin.cn/?target=https://www.postcss.com.cn/" title="https://www.postcss.com.cn/"># postcss官方文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\js\APlayer.min.js&quot; class=&quot;aplayer-se</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vite" scheme="http://example.com/tags/vite/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>【原创】NodeJs从入门到实战</title>
    <link href="http://example.com/posts/undefined/"/>
    <id>http://example.com/posts/undefined/</id>
    <published>2023-02-23T08:08:32.400Z</published>
    <updated>2023-03-03T09:39:05.390Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><h1 id="NodeJs从入门到实战"><a href="#NodeJs从入门到实战" class="headerlink" title="NodeJs从入门到实战"></a>NodeJs从入门到实战</h1><h5 id="作为一名热爱学习的前端工程师，想要获得更大的成长，除了积累原生JavaScript的相关知识，还是有必要掌握后端开发的，这样是从一个全端开发工程师彻底转变成大前端的一个必经之路！"><a href="#作为一名热爱学习的前端工程师，想要获得更大的成长，除了积累原生JavaScript的相关知识，还是有必要掌握后端开发的，这样是从一个全端开发工程师彻底转变成大前端的一个必经之路！" class="headerlink" title="作为一名热爱学习的前端工程师，想要获得更大的成长，除了积累原生JavaScript的相关知识，还是有必要掌握后端开发的，这样是从一个全端开发工程师彻底转变成大前端的一个必经之路！"></a>作为一名热爱学习的前端工程师，想要获得更大的成长，除了积累原生JavaScript的相关知识，还是有必要掌握后端开发的，这样是从一个全端开发工程师彻底转变成大前端的一个必经之路！</h5><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f34d3f6f914347905ce6e7a2f5a4b1~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>由于我平时对前端领域比较感兴趣，所以也曾开发过属于自己的个人网站，从Hexo脚手架搭建的博客站，到前后端分离的个人网站，以及后面所接触到的unicloud云开发，这其中也渐渐对nodejs技术有了更进一步的了解。</p><p>目前负责公司的一个可视化平台的后台服务器项目，从最初的技术选型到一步一步的搭建，测试，到最终部署到Linux系统上，以及后期的迭代更新，也收获满满。</p><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><p>因为是团队开发，我才用前后端分离的方式，具体技术栈如下：<br>服务端：NodeJs + Koa + sequelize + sqlite3<br>部署上线：pm2<br>代码管理： git</p><p>服务端技术架构图：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32441bb936064a03a5c24d8b224cb3fb~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="技术架构说明"><a href="#技术架构说明" class="headerlink" title="技术架构说明"></a>技术架构说明</h3><ul><li>这里我们采用node社区比较轻量的服务端框架Koa，然后服务端中间件有:   <ul><li>koa-static 提供静态资源访问，具体用途在项目实现细节里面会详细介绍</li><li>koa-body 处理请求报文，让koa可以方便的拿到post/put的数据</li><li>koa2-cors 本地联调时通过cors方式处理跨域问题</li><li>multer 用来处理文件上传</li><li>koa-router 用来编写服务端路由和api</li><li>koa-send 用于处理文件下载</li><li>axios HttpAPI请求工具, 这里是辅助前端进行第三方跨域请求</li><li>sequelize Node的ORM框架Sequelize来操作数据库，用于将关系数据库映射到对象上，然后进行的封装。</li></ul></li></ul><h5 id="上面就是我们web服务端主要使用的中间件，对于每一块如何去组织和架构，包括自己实现错误校验中间件，我会在后面一一介绍，由于写服务端的过程中也查阅了很多资料，如有不足或需要优化的地方，欢迎交流。"><a href="#上面就是我们web服务端主要使用的中间件，对于每一块如何去组织和架构，包括自己实现错误校验中间件，我会在后面一一介绍，由于写服务端的过程中也查阅了很多资料，如有不足或需要优化的地方，欢迎交流。" class="headerlink" title="上面就是我们web服务端主要使用的中间件，对于每一块如何去组织和架构，包括自己实现错误校验中间件，我会在后面一一介绍，由于写服务端的过程中也查阅了很多资料，如有不足或需要优化的地方，欢迎交流。"></a>上面就是我们web服务端主要使用的中间件，对于每一块如何去组织和架构，包括自己实现错误校验中间件，我会在后面一一介绍，由于写服务端的过程中也查阅了很多资料，如有不足或需要优化的地方，欢迎交流。</h5><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">model-sequelize/</span><br><span class="line">|</span><br><span class="line">+- .vscode/无</span><br><span class="line">|  |</span><br><span class="line">|  +- launch.json &lt;-- VSCode 配置文件</span><br><span class="line">|</span><br><span class="line">+- controller/接口函数</span><br><span class="line">|  +- applys.js &lt;-- 应用接口函数</span><br><span class="line">|  +- node_util.js &lt;-- 通用接口函数</span><br><span class="line">|  +- project.js &lt;-- 项目管理接口函数</span><br><span class="line">|  ……</span><br><span class="line">|</span><br><span class="line">+- lib/请求响应处理封装</span><br><span class="line">|  +- return.js &lt;-- 过滤响应</span><br><span class="line">| </span><br><span class="line">+- util/工具库</span><br><span class="line">|  +- init</span><br><span class="line">|  +- model</span><br><span class="line">|  </span><br><span class="line">+- view/前端静态代码托管</span><br><span class="line">|  +- </span><br><span class="line">| </span><br><span class="line">+- models/ &lt;-- 存放所有数据表映射关系</span><br><span class="line">|  +- project.js &lt;-- 项目管理</span><br><span class="line">|  ……</span><br><span class="line">|</span><br><span class="line">+- db.js &lt;-- 如何定义Model</span><br><span class="line">|</span><br><span class="line">+- model.js &lt;-- 如何导入Model</span><br><span class="line">|</span><br><span class="line">+- database.js &lt;-- 初始化数据库</span><br><span class="line">|</span><br><span class="line">+- database.sqlite &lt;-- sqlite3数据库文件</span><br><span class="line">|</span><br><span class="line">+- server.js &lt;-- 业务代码(总入口)</span><br><span class="line">|</span><br><span class="line">+- server.json &lt;-- 业务配置项</span><br><span class="line">|</span><br><span class="line">+- package.json &lt;-- 项目描述文件</span><br><span class="line">|</span><br><span class="line">+- node_modules/ &lt;-- npm安装的所有依赖包</span><br></pre></td></tr></table></figure><h2 id="常用功能精讲"><a href="#常用功能精讲" class="headerlink" title="常用功能精讲"></a>常用功能精讲</h2><h3 id="sequelize"><a href="#sequelize" class="headerlink" title="sequelize"></a>sequelize</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在没有sequelize之前，nodejs调用数据表，需要手写晦涩难懂的sql语句。</span><br><span class="line">而sequelize采用底层封装的思路，将数据表抽象成为对象，然后通过API进行实现增删改查。</span><br><span class="line">就如同vue解放了原生dom操作一般，有木有很方便。</span><br><span class="line">// 连接数据库</span><br><span class="line">const sequelize = new Sequelize(&#123;</span><br><span class="line">    host: &#x27;localhost&#x27;,</span><br><span class="line">    dialect: &#x27;sqlite&#x27;,</span><br><span class="line">    // timezone: &#x27;+08:00&#x27;,</span><br><span class="line">    pool: &#123;</span><br><span class="line">        max: 5,</span><br><span class="line">        min: 0,</span><br><span class="line">        acquire: 30000,</span><br><span class="line">        idle: 10000</span><br><span class="line">    &#125;,</span><br><span class="line">    storage: &#x27;database.sqlite&#x27;,</span><br><span class="line">    operatorsAliases: false</span><br><span class="line">&#125;);</span><br><span class="line">// 数据表建立 例子：</span><br><span class="line">module.exports = db.defineModel(&quot;user&quot;, &#123;</span><br><span class="line">    username: db.Sequelize.STRING,</span><br><span class="line">    password: db.Sequelize.STRING,</span><br><span class="line">    status: db.Sequelize.STRING,</span><br><span class="line">    token: db.Sequelize.STRING, // 保存至前端的加密信息 暂时由status+时间戳组成</span><br><span class="line">    wechat_sceneId:db.Sequelize.INTEGER, // 微信小程序所加载的场景id</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    // freezeTabelName 为 true 时不会在库中映射表时增加复数表名</span><br><span class="line">    // 该选项为 true 时，user 在映射时映射成 user，而为 false 时会映射成users</span><br><span class="line">    freezeTableName: true</span><br><span class="line">&#125;)</span><br><span class="line">// 多表关联建立 例子：</span><br><span class="line">// 关联一对多表查询</span><br><span class="line">applys.belongsTo(projects, &#123;</span><br><span class="line">    foreignKey:</span><br><span class="line">        &#x27;projectId&#x27;, targetKey: &#x27;id&#x27;</span><br><span class="line">&#125;);</span><br><span class="line">// 数据表的查询操作(其中model是我对所有数据表对象的封装)</span><br><span class="line">const userList=async ()=&gt;&#123;</span><br><span class="line">    let results = await model.user.findAll()</span><br><span class="line">    return results</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后想了解更多关于sequelize的使用，可以前往廖雪峰大佬的个人网站学习。<br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1101571555324224">##sequelize</a></p><h3 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在开发过程中的一个热更新插件supervisor</span><br></pre></td></tr></table></figure><h2 id="打包上线-打包成应用"><a href="#打包上线-打包成应用" class="headerlink" title="打包上线/打包成应用"></a>打包上线/打包成应用</h2><h3 id="进程常驻pm2"><a href="#进程常驻pm2" class="headerlink" title="进程常驻pm2"></a>进程常驻pm2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g pm2</span><br><span class="line">$ pm2 start app.js # 启动app.js应用程序</span><br><span class="line">$ pm2 start app.js -i 4        # cluster mode 模式启动4个app.js的应用实例</span><br><span class="line"># 4个应用程序会自动进行负载均衡</span><br><span class="line">$ pm2 start app.js --name=&quot;api&quot; # 启动应用程序并命名为 &quot;api&quot;</span><br><span class="line">$ pm2 start app.js --watch      # 当文件变化时自动重启应用</span><br><span class="line">$ pm2 start script.sh          # 启动 bash 脚本</span><br><span class="line">$ pm2 list                      # 列表 PM2 启动的所有的应用程序</span><br><span class="line">$ pm2 monit                    # 显示每个应用程序的CPU和内存占用情况</span><br><span class="line">$ pm2 show [app-name]          # 显示应用程序的所有信息</span><br><span class="line">$ pm2 logs                      # 显示所有应用程序的日志</span><br><span class="line">$ pm2 logs [app-name]          # 显示指定应用程序的日志</span><br><span class="line">$ pm2 flush                       # 清空所有日志文件</span><br><span class="line">$ pm2 stop all                  # 停止所有的应用程序</span><br><span class="line">$ pm2 stop 0                    # 停止 id为 0的指定应用程序</span><br><span class="line">$ pm2 restart all              # 重启所有应用</span><br><span class="line">$ pm2 reload all                # 重启 cluster mode下的所有应用</span><br><span class="line">$ pm2 gracefulReload all        # Graceful reload all apps in cluster mode</span><br><span class="line">$ pm2 delete all                # 关闭并删除所有应用</span><br><span class="line">$ pm2 delete 0                  # 删除指定应用 id 0</span><br><span class="line">$ pm2 scale api 10              # 把名字叫api的应用扩展到10个实例</span><br><span class="line">$ pm2 reset [app-name]          # 重置重启数量</span><br><span class="line">$ pm2 startup                  # 创建开机自启动命令</span><br><span class="line">$ pm2 save                      # 保存当前应用列表</span><br><span class="line">$ pm2 resurrect                # 重新加载保存的应用列表</span><br><span class="line">$ pm2 update                    # Save processes, kill PM2 and restore processes</span><br><span class="line">$ pm2 generate                  # Generate a sample json configuration file</span><br><span class="line">pm2文档地址：http://pm2.keymetrics.io/docs/usage/quick-start/</span><br></pre></td></tr></table></figure><h3 id="mysql数据库连接功能相关知识"><a href="#mysql数据库连接功能相关知识" class="headerlink" title="mysql数据库连接功能相关知识"></a>mysql数据库连接功能相关知识</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启本地数据库局域网访问</span><br><span class="line">1、更新root账户的权限。打开mysql命令行窗口，输入</span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to root@&quot;%&quot; identified by &#x27;abc&#x27; with grant option;  flush privileges;</span><br><span class="line"></span><br><span class="line">上述语句的完整模板为：</span><br><span class="line"></span><br><span class="line">grant all privileges on 库名.表名 to &#x27;用户名&#x27;@&#x27;IP地址&#x27; identified by &#x27;密码&#x27; with grant option;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">测试，没有问题。</span><br><span class="line"></span><br><span class="line">2、创建一个新账户，如guest，并将可被访问的主机定义为%，即所有主机都可访问该账户。</span><br><span class="line"></span><br><span class="line">测试，没有问题。</span><br><span class="line">参考：</span><br><span class="line">https://jingyan.baidu.com/article/6dad50755e3dd1a123e36ec4.html</span><br></pre></td></tr></table></figure><h3 id="docker打包镜像"><a href="#docker打包镜像" class="headerlink" title="docker打包镜像"></a>docker打包镜像</h3><ul><li>window上要使用docker,可以使用docker desktop工具<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装和运行docker desktop</span><br><span class="line">测试demo</span><br><span class="line">执行步骤1-clone  克隆仓库镜像</span><br><span class="line">执行步骤2-build 编译</span><br><span class="line">执行步骤3-run</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>创建配置项</p><ul><li>Dockerfile</li></ul> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM node:12.13.0</span><br><span class="line"></span><br><span class="line"># Create app directory</span><br><span class="line">WORKDIR /usr/src/app</span><br><span class="line"></span><br><span class="line"># Install app dependencies</span><br><span class="line"># A wildcard is used to ensure both package.json AND package-lock.json    are copied</span><br><span class="line"># where available (npm@5+)</span><br><span class="line">COPY package*.json ./</span><br><span class="line"></span><br><span class="line">RUN yarn install</span><br><span class="line">#RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line"># If you are building your code for production</span><br><span class="line">#RUN npm ci --only=production</span><br><span class="line"></span><br><span class="line"># Bundle app source</span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD [ &quot;node&quot;, &quot;server.js&quot; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>dockerignore<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">.svn</span><br><span class="line">node_modules</span><br><span class="line">public</span><br><span class="line">static/model</span><br><span class="line">database.sqlite</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>编译打包服务端项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  编译</span><br><span class="line">  docker build -t yanyufanchen/node-web-app .    </span><br><span class="line">node-web-app为打包的镜像名称  可以用:用户名/镜像名</span><br><span class="line">查看所有镜像</span><br><span class="line">docker images</span><br><span class="line">修改标签</span><br><span class="line">docker tag IMAGEID(镜像id) REPOSITORY:TAG（用户名/镜像名：标签）</span><br><span class="line">运行镜像</span><br><span class="line">docker run -p 3000:3000 -d 镜像名      映射端口49160:原有端口8080</span><br><span class="line">推送远程仓库</span><br><span class="line">docker push 镜像名称:标签</span><br><span class="line">删除镜像</span><br><span class="line">docker rmi -f 241c2cc33dde(镜像名称)</span><br><span class="line">查看容器</span><br><span class="line">docker ps</span><br><span class="line">停止容器</span><br><span class="line">docker stop</span><br><span class="line">删除容器</span><br><span class="line">docker rm -f</span><br></pre></td></tr></table></figure><ul><li>遇到的问题<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装docker desktop工具后出现提示”wsl2 installation is incomplete“</span><br><span class="line">原因：是没有安装linux在windows的子系统，可以在window store上下载debian工具</span><br><span class="line">解决方案：https://www.jiloc.com/45016.html</span><br><span class="line">1、安装debian</span><br><span class="line">2、启动debian</span><br><span class="line">3、注册账号密码 </span><br><span class="line">依然没有解决，安装wsl更新包</span><br><span class="line">https://www.cnblogs.com/xiluhua/p/14120713.html</span><br><span class="line">https://github.com/xiluhua/docker-desktop</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="代码混淆-uglify-es混淆"><a href="#代码混淆-uglify-es混淆" class="headerlink" title="代码混淆 uglify-es混淆"></a>代码混淆 uglify-es混淆</h3><p>安装</p><p>From NPM for use as a command line app:</p><p><code>npm install uglify-es -g</code></p><p>From NPM for programmatic use:</p><p><code>npm install uglify-es</code></p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">混用多个混淆属性选项：</span><br><span class="line">uglifyjs example.js -c -m --mangle-props regex=/_$/,reserved=[bar_]</span><br><span class="line">混淆并输出到指定目录下</span><br><span class="line">uglifyjs text2.js -o out/text2.js  -c -m --mangle-props regex=/_$/,reserved=[bar_]</span><br></pre></td></tr></table></figure><p>地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uglify-js只能混淆es5以下</span><br><span class="line">参考中文文档</span><br><span class="line">http://www.suoniao.com/article/52</span><br><span class="line">uglify-es可以混淆es6</span><br><span class="line">https://github.com/mishoo/UglifyJS/tree/harmony</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.jianshu.com/p/b988ce30bac3?from=singlemessage">koa学习</a></li><li><a href="https://www.pengwang.xyz/">我的大前端个人网站</a></li><li><a href="http://www.ptbird.cn/koa-body.html">关于中间件koa-body</a></li><li><a href="https://blog.csdn.net/duninet/article/details/103047040">文件上传</a></li><li><a href="https://www.cnblogs.com/mordom/archive/2018/01/23/8337337.html">pkg 打包node应用</a></li><li><a href="https://www.cnblogs.com/vipzhou/p/6559991.html">制作测试api文档</a></li></ul>]]></content>
    
    
    <summary type="html">作为一名热爱学习的前端工程师，想要获得更大的成长，除了积累原生JavaScript的相关知识，还是有必要掌握后端开发的，这样是从一个全端开发工程师彻底转变成大前端的一个必经之路！</summary>
    
    
    
    <category term="后端" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Nodejs" scheme="http://example.com/tags/Nodejs/"/>
    
    <category term="后端" scheme="http://example.com/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
